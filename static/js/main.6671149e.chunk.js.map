{"version":3,"sources":["libs/chip/assets/characters.ts","libs/chip/drivers/cpu.ts","libs/chip/drivers/gfx.ts","libs/chip/chip.ts","containers/App/App.tsx","reportWebVitals.ts","index.tsx"],"names":["fonts","Cpu","rom","gfx","memory","Uint8Array","ArrayBuffer","registers","stack","Uint16Array","stackPointer","counter","pointer","screen","delayTimer","soundTimer","keys","key","running","this","resolution","x","y","load","loadFont","map","instruction","address","addressMap","start","char","index","tick","opcode","NN","JUMP","didJump","console","log","warn","Error","toString","Math","floor","random","spr","height","coordinates","vertical","horizontal","scale","setPixel","oldKeyDown","setKey","self","bind","apply","stop","pointers","i","width","location","display","Gfx","canvas","colors","background","foreground","context","current","boot","getContext","disp_clear","clearRect","pixel","position","fillStyle","fillRect","Chip","fps","frame","cpu","then","performance","now","interval","requestAnimationFrame","animateLoop","delta","next","paint","cancelAnimationFrame","App","useState","booted","setBooted","useRef","config","state","setState","useEffect","a","request","url","process","method","responseType","response","blob","Blob","data","arrayBuffer","buffer","chip","window","isClient","fetchData","className","data-testid","ref","initialValues","onSubmit","values","type","name","id","min","htmlFor","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6671149e.chunk.js","sourcesContent":["export const fonts = [\n  0xf0,\n  0x90,\n  0x90,\n  0x90,\n  0xf0, // 0\n  0x20,\n  0x60,\n  0x20,\n  0x20,\n  0x70, // 1\n  0xf0,\n  0x10,\n  0xf0,\n  0x80,\n  0xf0, // 2\n  0xf0,\n  0x10,\n  0xf0,\n  0x10,\n  0xf0, // 3\n  0x90,\n  0x90,\n  0xf0,\n  0x10,\n  0x10, // 4\n  0xf0,\n  0x80,\n  0xf0,\n  0x10,\n  0xf0, // 5\n  0xf0,\n  0x80,\n  0xf0,\n  0x90,\n  0xf0, // 6\n  0xf0,\n  0x10,\n  0x20,\n  0x40,\n  0x40, // 7\n  0xf0,\n  0x90,\n  0xf0,\n  0x90,\n  0xf0, // 8\n  0xf0,\n  0x90,\n  0xf0,\n  0x10,\n  0xf0, // 9\n  0xf0,\n  0x90,\n  0xf0,\n  0x90,\n  0x90, // A\n  0xe0,\n  0x90,\n  0xe0,\n  0x90,\n  0xe0, // B\n  0xf0,\n  0x80,\n  0x80,\n  0x80,\n  0xf0, // C\n  0xe0,\n  0x90,\n  0x90,\n  0x90,\n  0xe0, // D\n  0xf0,\n  0x80,\n  0xf0,\n  0x80,\n  0xf0, // E\n  0xf0,\n  0x80,\n  0xf0,\n  0x80,\n  0x80 // F\n];\n","/**\n *\n * CHIP-8 CPU emulator class\n * @author Darryl Walker\n *\n */\n\nimport Gfx from './gfx';\nimport { fonts } from '../assets/characters';\n\nexport default class Cpu {\n  /**\n   * CHIP-8 has 4096 8-bit (1 byte) memory locations\n   * A byte is normally the smallest addressable location\n   * Each byte can be a value of 0-255\n   *\n   * Our 4096 decimal can expressed as 0x1000 in hexadecimal\n   * We will create a new ArrayBuffer and pass it to Uint8Array (unsigned integer with a range of 0-255)\n   * Array buffer will handle our raw data for us e.g. 0x1000 => 4096\n   */\n\n  memory = new Uint8Array(new ArrayBuffer(0x1000));\n\n  /**\n   * CHIP-8 has 16 8-bit data registers named V0 to VF\n   * We create a new Uint8Array with 16 register locations\n   */\n\n  registers = new Uint8Array(16);\n\n  /**\n   * Our stack will need to store return addresses\n   * We will need 16 of these 16-bit addresses\n   */\n\n  stack = new Uint16Array(16);\n\n  /**\n   * Our stack pointer will store where in our 16 length stack we should be\n   */\n\n  stackPointer = 0;\n\n  /**\n   * We need to define our program counter\n   * This is the next instruction that should be executed by our cpu\n   * CHIP-8 starts at 0x200 leaving the lowest 512 bytes (0-511) free\n   * We'll store font data there later\n   */\n\n  counter = 0x200;\n\n  /**\n   * Assign a position for our graphics adapter\n   */\n\n  gfx;\n\n  /**\n   * okay so this is a pointer i've called pointer\n   * in reality it's confusingly called \"I\"\n   * i like mine better for now\n   * on the CHIP-8 it's a 16-bit register so a regular number is fine\n   */\n\n  pointer = 0;\n\n  /**\n   * Our screen space will be an array representing pixels\n   * left to right, top to bottom, 8-bits (1-byte) each\n   */\n\n  public screen = new Uint8Array();\n\n  /**\n   * we have two timers- one for delay and one for sound\n   */\n\n  delayTimer = 0;\n  soundTimer = 0;\n\n  /**\n   * We need a key-value store for CHIP-8\n   * We can just use a plain object for this\n   */\n\n  keys: IKeys = {};\n\n  /**\n   * at any given time we can have one key pressed\n   * so we'll keep track of it via a pointer\n   */\n\n  key = 0;\n\n  /**\n   * We need a way to track whether or not ops should be paused\n   * a boolean will do\n   */\n\n  running = false;\n\n  constructor(rom: Uint8Array, gfx: Gfx) {\n    this.gfx = gfx;\n    this.screen = new Uint8Array(this.gfx.resolution.x * this.gfx.resolution.y);\n    this.load(rom);\n  }\n\n  /**\n   * We take the ROM file represented as a Uint8Array and map into memory\n   * Here we need to ecounter for the original interpreter positions\n   * For this reason, most programs written for the original system begin at memory location 512 (0x200)\n   * We shift all the memory addresses over by 512 (or 0x200 for fun)\n   */\n\n  load(rom: Uint8Array) {\n    /**\n     * load fonts first\n     */\n\n    this.loadFont();\n\n    rom.map((instruction, address) => {\n      /**\n       * take the instrction and the array index as our memory address\n       * map this into our emulators memory\n       */\n\n      const addressMap = address + 0x200;\n\n      this.memory[addressMap] = instruction;\n\n      return instruction;\n    });\n\n    /**\n     * it's always useful if you remember to start the engine\n     */\n    this.start();\n  }\n\n  /**\n   * We need to load a hexadecimal character set into the first few bytes of our memory\n   * we have 512 free slots to play with in total\n   */\n  loadFont() {\n    return fonts.map((char, index) => {\n      return (this.memory[index] = char);\n    });\n  }\n\n  public start() {\n    this.running = true;\n  }\n\n  public stop() {\n    this.running = false;\n  }\n\n  /**\n   * We will provided a handle little API for the chip to call for a tick at the preferred rate\n   * next will check if the cpu is running and tick if true\n   */\n\n  public next() {\n    if (!this.running) {\n      return;\n    }\n\n    this.tick();\n  }\n\n  /**\n   * Our processor will perform an instruction once per tick\n   * During this time we will check the opcode and see what it needs to do\n   */\n\n  tick() {\n    /**\n     * before we do anything we have to decrement our timers\n     */\n\n    if (this.delayTimer > 0) {\n      --this.delayTimer;\n    }\n\n    if (this.soundTimer > 0) {\n      --this.soundTimer;\n    }\n\n    /**\n     * This bit is a little confusing to me\n     * I learned a lot of it from reading\n     * https://github.com/alexanderdickson/Chip-8-Emulator/blob/5da6ac6a4753462d02ca7fe8d5a9398308b8d9d0/scripts/chip8.js#L193\n     * We're shifting everything over bitwise 8 to the left\n     * And then doing a bitwise or on each pair of bits. a OR b yields 1 if either a or b is 1.\n     *\n     * UPDATE\n     * Bless this dude, who seems to be the reference for the above JS dude/dudette\n     * https://github.com/eshyong/Chip-8-Emulator/blob/master/chip8.c\n     *\n     * Opcodes are two bytes long!\n     * We're creating a hexidecimal here, I guess? Out of the two byte opcode\n     *\n     * here we take the first complete bite\n     * in pongs case that's 6A hex / 106 decimal√é\n     * we also take the next byte which is conveniently 02 hex / 2 decimal\n     *\n     * fuck me\n     * i guess this is a clever way of storing integers greater than 8 bits\n     * which is cool as shit\n     *\n     * we take decimal 106 and we shift it left 8 places giving us decimal 27136\n     *\n     * then we take output of that left shift and give it to a bitwise OR - the single pipe dude\n     * this guy adds them together\n     * problem: 27136 | 2\n     * result: 27138 decimal / 6a02 hex\n     *\n     * i guess we just got two bytes of storage out of one byte of data\n     * how very... bitwise\n     *\n     */\n\n    const opcode =\n      (this.memory[this.counter] << 8) | this.memory[this.counter + 1];\n\n    /**\n     * here a bitwise AND (&) compares two numbers and casts them to numbers if they arent numbers\n     * my head hurts\n     *\n     * Read here:\n     * https://en.wikipedia.org/wiki/Bitwise_operation#AND\n     *\n     * Okay.\n     * There's a lot going on here.\n     * X is a two parter, first we take our opcode 27136 and give it 0x0f00 hex / 3840 decimal\n     * this yields a00 hex / 2560 decimal\n     *\n     * we then shift the result over 8 places right yielding a hex / 10 decimal\n     * giving us our register address for later!\n     *\n     * do similar for y taking 27136 and giving it 0x0000 hex / 0 decimal and go god i keep flopping back and forth\n     * it's all hex i swear just different hex and i will tidy it up just look at the decimals\n     *\n     * shift it over 4 and it's still 0 / 0x0000\n     *\n     */\n\n    const x = (opcode & 0x0f00) >> 8;\n    const y = (opcode & 0x00f0) >> 4;\n    const NN = opcode & 0x00ff;\n    const JUMP = opcode & 0x0fff;\n    let didJump = false;\n\n    /**\n     * then start checking opcodes\n     *\n     * our first check is the result of opcode AND 0xf000\n     * continuing with the above we have 27138 & 61440 = 24576 decimal / 0x6000 hex\n     *\n     * this corresponds to opcode 6XNN!\n     * https://en.wikipedia.org/wiki/CHIP-8#Opcode_table\n     *\n     * this is called checking the first nibble of the byte\n     */\n\n    switch (opcode & 0xf000) {\n      /**\n       * 0000\n       * This can be a few things but we only really care about two of them - 00E0 and 00EE\n       */\n      case 0x0000: {\n        switch (opcode) {\n          /**\n           * 00E0 / disp_clear() - clears the screen\n           */\n          case 0x00e0:\n            console.log(this.counter, 'Render clear');\n            break;\n\n          /**\n           * 00EE / return from a subroutine\n           */\n          case 0x00ee:\n            if (this.stack[this.stackPointer] === 0) {\n              console.warn('Invalid return from subroutine.');\n            }\n\n            this.counter = this.stack[this.stackPointer];\n            this.stack[this.stackPointer] = 0;\n\n            if (this.stackPointer > 0) {\n              --this.stackPointer;\n            }\n\n            console.log(\n              this.counter,\n              'Return from subroutine',\n              this.counter,\n              this.stack,\n              this.stackPointer\n            );\n            break;\n        }\n        break;\n      }\n\n      /**\n       * 1NNN - Jumps to address NNN.\n       */\n      case 0x1000: {\n        this.counter = JUMP;\n        didJump = true;\n        break;\n      }\n\n      /**\n       * 2NNN - Calls subroutine at NNN.\n       * Updates the counter to the next instruction\n       * We store the return address for later and increment our stack size\n       */\n      case 0x2000: {\n        if (this.stack[this.stackPointer] !== 0) {\n          ++this.stackPointer;\n        }\n        this.stack[this.stackPointer] = this.counter;\n        this.counter = JUMP;\n        didJump = true;\n\n        console.log(\n          this.counter,\n          'calling subroutine',\n          JUMP,\n          this.counter,\n          this.stackPointer,\n          this.stack\n        );\n        break;\n      }\n\n      /**\n       * 3XNN/if(Vx==NN) - Skips the next instruction if VX equals NN. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x3000: {\n        console.log(this.counter, 'Skip instruction check if VX === NN');\n        if (this.registers[x] === NN) {\n          console.log('Skipped');\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * 4XNN/if(Vx!=NN - Skips the next instruction if VX doesn't equal NN. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x4000: {\n        console.log(this.counter, 'Skip instruction check if VX !== NN');\n        if (this.registers[x] !== NN) {\n          console.log('Skipped');\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * 5XY0/if(Vx==Vy) - Skips the next instruction if VX equals VY. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x5000: {\n        console.log(this.counter, 'Skip instruction check if VX === VY');\n        if (this.registers[x] === this.registers[y]) {\n          console.log('Skipped');\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * 6XNN - Sets VX to NN\n       * opcode AND 0xFF hex / 255 dec = 2 dec / 02 hex\n       * therefore register 10 now has a value of two\n       */\n      case 0x6000: {\n        console.log(this.counter, 'Setting VX to NN', x, opcode & 0xff);\n        this.registers[x] = opcode & 0xff;\n        break;\n      }\n\n      /**\n       * 7XNN - Adds NN to VX. (Carry flag is not changed)\n       */\n      case 0x7000: {\n        console.log(this.counter, 'Adding NN to VX', x, this.registers[x], NN);\n        this.registers[x] += NN;\n        break;\n      }\n\n      /**\n       * 8000 is an imposing list of VX and VY operations\n       */\n\n      case 0x8000: {\n        switch (opcode & 0x000f) {\n          /**\n           * 8XY0/Vx=Vy - Sets VX to the value of VY.\n           */\n          case 0x0000: {\n            console.log(this.counter, 'Setting VX to VY');\n            this.registers[x] = this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY1/Vx=Vx|Vy - Sets VX to VX or VY. (Bitwise OR operation)\n           */\n          case 0x0001: {\n            console.log(this.counter, 'Setting VX to VX or VY');\n            this.registers[x] = this.registers[x] | this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY2/Vx=Vx&Vy - Sets VX to VX and VY. (Bitwise AND operation)\n           */\n          case 0x0002: {\n            console.log(this.counter, 'Setting VX to VX and VY');\n            this.registers[x] = this.registers[x] & this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY3/Vx=Vx^Vy - Sets VX to VX xor VY.\n           */\n          case 0x0003: {\n            console.log(this.counter, 'Setting VX to VX xor VY');\n            this.registers[x] = this.registers[x] ^ this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY4/Vx += Vy - Adds VY to VX. VF is set to 1 when there's a carry, and to 0 when there isn't.\n           */\n          case 0x0004: {\n            console.log(this.counter, 'Adding VY to VX');\n            if (this.registers[x] + this.registers[y] > 255) {\n              this.registers[0xf] = 1;\n            } else {\n              this.registers[0xf] = 0;\n            }\n            this.registers[x] += this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY5/Vx -= Vy - VY is subtracted from VX. VF is set to 0 when there's a borrow, and 1 when there isn't.\n           */\n          case 0x0005: {\n            console.log(this.counter, 'Subtracting VY from VX');\n            if (this.registers[x] < this.registers[y]) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] -= this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY6/Vx>>=1 - Stores the least significant bit of VX in VF and then shifts VX to the right by 1.\n           */\n          case 0x0006: {\n            console.log(\n              this.counter,\n              'Storing least significant bit of VX in VF and right shift'\n            );\n            if (this.registers[x] % 2 === 0) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] = this.registers[x] >> 1;\n            break;\n          }\n\n          /**\n           * 8XY7/Vx=Vy-Vx - Sets VX to VY minus VX. VF is set to 0 when there's a borrow, and 1 when there isn't.\n           */\n          case 0x0007: {\n            console.log(this.counter, 'Setting VX to VY minus VX');\n            if (this.registers[y] < this.registers[x]) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] = this.registers[y] - this.registers[x];\n            break;\n          }\n\n          /**\n           * 8XYE/Vx<<=1 - Stores the most significant bit of VX in VF and then shifts VX to the left by 1\n           */\n          case 0x000e: {\n            console.log(\n              this.counter,\n              'Storing most significant bit of VX in VF and left shift'\n            );\n            if (this.registers[x] < 128) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] = this.registers[x] << 1;\n            break;\n          }\n          default: {\n            throw new Error(\n              `Unknown opcode in 8000 block: ${opcode.toString(16)}`\n            );\n          }\n        }\n        break;\n      }\n\n      /**\n       * ANNN - Sets pointer/I to address NNN\n       */\n      case 0xa000: {\n        console.log(this.counter, 'Setting I Pointer', this.pointer, JUMP);\n        this.pointer = JUMP;\n        break;\n      }\n\n      /**\n       * BNNN - Jumps to addres that is sum of NNN and V0 (register 0)\n       */\n      case 0xb000: {\n        console.log(\n          this.counter,\n          'Jumping to',\n          (opcode & 0xfff) + this.registers[0]\n        );\n        this.counter = (opcode & 0xfff) + this.registers[0];\n        didJump = true;\n        break;\n      }\n\n      /**\n       * CXNN/Vx=rand()&N - Sets VX to the result of a bitwise and operation on a random number (Typically: 0 to 255) and NN.\n       */\n      case 0xc000: {\n        console.log(this.counter, 'Setting VX to random number');\n        this.registers[x] = Math.floor(Math.random() * 255) % 255 & NN;\n        break;\n      }\n\n      /**\n       * DXYN / draw(Vx,Vy,N) - Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N+1 pixels.\n       */\n      case 0xd000: {\n        const height = opcode & 0x000f;\n\n        /**\n         * get our x and y coordinates from our register\n         * use values at position VX and VY\n         */\n\n        let coordinates: ICoordinates = {\n          x: this.registers[x],\n          y: this.registers[y]\n        };\n\n        this.screen[this.counter] = 1;\n\n        // set carry flag to 0\n        this.registers[0xf] = 0;\n\n        console.log(this.counter, 'Drawing', coordinates, height);\n\n        let spr;\n\n        /**\n         * drawing loop\n         * try not to get it backwards like i did\n         */\n        for (let vertical = 0; vertical < height; vertical++) {\n          spr = this.memory[this.pointer + vertical];\n          console.log(spr, this.pointer, vertical);\n\n          for (\n            let horizontal = 0;\n            horizontal < this.gfx.resolution.scale;\n            horizontal++\n          ) {\n            if (coordinates.x + horizontal === this.gfx.resolution.x) {\n              coordinates.x = -horizontal;\n            }\n            if (coordinates.y + vertical === this.gfx.resolution.y) {\n              coordinates.y = -vertical;\n            }\n\n            if ((spr & 0x80) > 0) {\n              if (\n                this.setPixel(\n                  this.registers[x] + horizontal,\n                  this.registers[y] + vertical\n                )\n              ) {\n                this.registers[0xf] = 1;\n              }\n            }\n            spr <<= 1;\n          }\n          coordinates.x = this.registers[x];\n          coordinates.y = this.registers[y];\n        }\n\n        break;\n      }\n\n      /**\n       * E000 can be one of two things, both bound to key presses\n       * they are kind of the opposite of one another\n       */\n      case 0xe000: {\n        switch (NN) {\n          /**\n           * EX9E/if(key()==Vx) - Skips the next instruction if the key stored in VX is pressed. (Usually the next instruction is a jump to skip a code block)\n           */\n          case 0x009e: {\n            console.log(this.counter, 'Checking if a key is pressed');\n            if (this.key === this.registers[x]) {\n              console.log('Key press, skipping');\n              this.counter += 2;\n            }\n            break;\n          }\n\n          /**\n           * EXA1/if(key()!=Vx) - Skips the next instruction if the key stored in VX isn't pressed. (Usually the next instruction is a jump to skip a code block)\n           */\n          case 0x00a1: {\n            console.log(this.counter, 'Checking if no key is pressed');\n            if (this.key !== this.registers[x]) {\n              console.log('No key press, skipping');\n              this.counter += 2;\n            }\n            break;\n          }\n          default: {\n            throw new Error(\n              `Unknown opcode in e000 block: ${opcode.toString(16)}`\n            );\n          }\n        }\n        break;\n      }\n\n      /**\n       * ol mate F000 can be a few things\n       */\n      case 0xf000: {\n        switch (NN) {\n          /**\n           * FX07/get_delay() -\tSets VX to the value of the delay timer.\n           */\n          case 0x0007: {\n            console.log(\n              this.counter,\n              'Setting VX to delay value',\n              x,\n              this.delayTimer\n            );\n            this.registers[x] = this.delayTimer;\n            break;\n          }\n          /**\n           * FX0A/get_key() - A key press is awaited, and then stored in VX. (Blocking Operation. All instruction halted until next key event)\n           * What this means is we are actually going to halt the program and wait until a key is pressed\n           */\n          case 0x000a: {\n            console.log(this.counter, 'waiting for get_key()');\n            const oldKeyDown = this.setKey;\n            const self = this;\n\n            this.setKey = function (key: number) {\n              self.registers[x] = key;\n\n              self.setKey = oldKeyDown.bind(self);\n              self.setKey.apply(self, [key]);\n\n              self.start();\n            };\n\n            this.stop();\n            return;\n          }\n\n          /**\n           * FX15/delay_timer(Vx) - Sets the delay timer to VX.\n           */\n          case 0x0015: {\n            console.log(\n              this.counter,\n              'setting delay timer to vx',\n              this.delayTimer,\n              this.registers[x]\n            );\n            this.delayTimer = this.registers[x];\n            break;\n          }\n\n          /**\n           * FX18/sound_timer(Vx) - Sets the sound timer to VX.\n           */\n          case 0x0018: {\n            console.log(\n              this.counter,\n              'setting sound timer to vx',\n              this.soundTimer,\n              this.registers[x]\n            );\n            this.soundTimer = this.registers[x];\n            break;\n          }\n\n          /**\n           * X1E - Adds VX to pointer/I. VF is not affected\n           */\n          case 0x001e: {\n            console.log(this.counter, 'adding vx to pointer');\n            this.pointer += this.registers[x];\n            break;\n          }\n\n          /**\n           * FX29 - I=sprite_addr[Vx] - Sets I to the location of the sprite for the character in VX.\n           * Characters 0-F (in hexadecimal) are represented by a 4x5 font.\n           * we multiply by 5 to get there\n           */\n          case 0x0029: {\n            console.log(\n              this.counter,\n              'Setting I to sprite location for char in vx',\n              this.pointer,\n              this.registers[x] * 5\n            );\n            this.pointer = this.registers[x] * 5;\n            break;\n          }\n\n          /**\n           * FX33/set_BCD - Stores the binary-coded decimal representation of VX, with the most significant of\n           * three digits at the address in I, the middle digit at I plus 1, and the least significant digit at\n           * I plus 2. (In other words, take the decimal representation of VX, place the hundreds digit in memory\n           * at location in I, the tens digit at location I+1, and the ones digit at location I+2.)\n           */\n          case 0x0033: {\n            const pointers = [\n              this.registers[x] / 100,\n              (this.registers[x] / 10) % 10,\n              this.registers[x] % 10\n            ];\n            console.log(\n              this.counter,\n              'set_BCD',\n              x,\n              this.registers[x],\n              pointers\n            );\n            this.memory[this.pointer] = pointers[0];\n            this.memory[this.pointer + 1] = pointers[1];\n            this.memory[this.pointer + 2] = pointers[2];\n            break;\n          }\n\n          /**\n           * FX55/reg_dump(Vx,&I) - Stores V0 to VX (including VX) in memory starting at address I.\n           */\n          case 0x0055: {\n            console.log(this.counter, 'reg_dump');\n            for (let i = 0; i <= x; i++) {\n              this.memory[this.pointer + i] = this.registers[i];\n            }\n            break;\n          }\n\n          /**\n           * FX65/reg_load(Vx,&I) - Fills V0 to VX (including VX) with values from memory starting at address I.\n           */\n          case 0x0065: {\n            console.log(this.counter, 'reg_load');\n            for (let i = 0; i <= x; i++) {\n              this.registers[i] = this.memory[this.pointer + i];\n            }\n            this.pointer = this.pointer + x + 1;\n            break;\n          }\n        }\n        break;\n      }\n      default: {\n        throw new Error(`Unknown opcode: ${opcode.toString(16)}`);\n      }\n    }\n\n    /**\n     * all of our instructions are two bytes long\n     * increment our counter+2 to move to the next instruction by default\n     */\n\n    if (!didJump) {\n      this.counter += 2;\n    }\n  }\n\n  get display() {\n    return this.screen;\n  }\n\n  setKey(key: number) {\n    this.keys[key] = true;\n  }\n\n  /**\n   * do our set pixel handling here\n   */\n  setPixel(x: number, y: number) {\n    const width = this.gfx.resolution.x;\n    const height = this.gfx.resolution.y;\n\n    // If the pixel exceeds the dimensions,\n    // wrap it back around.\n    if (x > width) {\n      x -= width;\n    } else if (x < 0) {\n      x += width;\n    }\n\n    if (y > height) {\n      y -= height;\n    } else if (y < 0) {\n      y += height;\n    }\n\n    const location = x + y * width;\n\n    this.display[location] ^= 1;\n\n    return !this.screen[location];\n  }\n}\n\nexport interface ICoordinates {\n  x: number;\n  y: number;\n}\n\nexport interface IKeys {\n  [key: number]: any;\n}\n","/**\n *\n * CHIP.ts canvas render methods\n * @author Darryl Walker\n *\n */\n\nexport default class Gfx {\n  /**\n   * we get 2 whole colours to play with here\n   * our background will be black and our foreground classic monochrome green\n   */\n\n  colors = {\n    background: '#000',\n    foreground: '#00ff00'\n  };\n\n  /**\n   * This class will receive input from a buffer and draw a new screen\n   * Canvas is convenient and cool so we'll use that\n   */\n\n  canvas: any = null;\n  context: CanvasRenderingContext2D | null = null;\n\n  /**\n   * Here we configure graphics information\n   * CHIP-8 has a display resolution of 64x32 and we'll scale it up 8 times\n   * Our poor renderer is bound to his resolution forever :(\n   */\n\n  public resolution = {\n    x: 64,\n    y: 32,\n    scale: 8\n  };\n\n  /**\n   * giving up and resorting to any type\n   * seems to work now\n   * we'll assign our canvas to a local property\n   */\n\n  constructor(canvas: any) {\n    this.canvas = canvas.current;\n    this.boot();\n  }\n\n  /**\n   * Some basic canvas stuff here we're going to get a 2d canvas context\n   * we're going to give the canvas height and width dimension * scale\n   */\n\n  boot() {\n    this.context = this.canvas.getContext('2d');\n    this.canvas.width = this.resolution.x * this.resolution.scale;\n    this.canvas.height = this.resolution.y * this.resolution.scale;\n\n    this.disp_clear();\n  }\n\n  disp_clear() {\n    /**\n     * man i cannot get typescript to shut the fuck about how this might be null\n     * look at all this extra code\n     * i love typescript but she doesnt make it easy\n     */\n    this.context?.clearRect &&\n      this.context.clearRect(\n        0,\n        0,\n        this.resolution.x * this.resolution.scale,\n        this.resolution.y * this.resolution.scale\n      );\n  }\n\n  public paint(screen: Uint8Array) {\n    /**\n     * Start every render by clearing the screen\n     */\n    this.disp_clear();\n\n    if (this.context) {\n      const context = this.context;\n      const resolution = this.resolution;\n\n      screen.map((pixel, position) => {\n        /**\n         * return the remainder of the position and get multiply it by our scale to get our x/y position\n         */\n        const x = (position % resolution.x) * resolution.scale;\n        const y = Math.floor(position / resolution.x) * resolution.scale;\n\n        /**\n         * our pixel is either on or off (0 or 1) so here we present an array with two options\n         * off is 0 or background color\n         * on is 1 or foreground color\n         */\n\n        context.fillStyle = [this.colors.background, this.colors.foreground][\n          pixel\n        ];\n\n        /**\n         * at our x and y coordinate paint a a square matching our scale size and fill color\n         */\n\n        context.fillRect(x, y, this.resolution.scale, this.resolution.scale);\n\n        return pixel;\n      });\n    }\n  }\n}\n","/**\n *\n * CHIP.ts - A CHIP-8 emulator in TypeScript\n * @author Darryl Walker\n *\n */\n\nimport Cpu from './drivers/cpu';\nimport Gfx from './drivers/gfx';\n\nexport default class Chip {\n  /**\n   * Configure our preferred target framerate\n   * We'll also configure our frame pointer and play state\n   * Timing function from https://gist.github.com/addyosmani/5434533#gistcomment-2018050\n   */\n\n  fps = 60;\n  frame = 0;\n\n  /**\n   * stub our cpu and gfx so we can access them publicly\n   */\n\n  public cpu;\n  public gfx;\n\n  /**\n   * i couldnt figure out how to make typescript happy with canvas so i've checked it can't be null up the chain - bit risky tho\n   *\n   * @param rom - a CHIP-8 rom file as a Uint8Array\n   * @param canvas - an html canvas element for our renderer\n   */\n\n  constructor(rom: Uint8Array, canvas: any, fps?: number) {\n    const gfx = new Gfx(canvas);\n    const cpu = new Cpu(rom, gfx);\n\n    if (fps) {\n      this.fps = fps;\n    }\n\n    this.cpu = cpu;\n    this.gfx = gfx;\n\n    this.start(cpu, gfx);\n  }\n\n  /**\n   * start will kick off our timing function\n   * this is going to check 60 times per second\n   * requestAnimationFrame is a browser API that helps us\n   * with render timing\n   */\n\n  start(cpu: Cpu, gfx: Gfx) {\n    /**\n     * I just learned about performance\n     * This is cool\n     */\n\n    let then: number = performance.now();\n\n    const interval = 1000 / this.fps;\n    const tolerance = 0.1;\n\n    const animateLoop = (now: number) => {\n      this.frame = requestAnimationFrame(animateLoop);\n\n      const delta = now - then;\n\n      if (delta >= interval - tolerance) {\n        then = now - (delta % interval);\n\n        /**\n         * Code within this block is executed once per frame\n         */\n\n        cpu.next();\n\n        const screen = cpu.display;\n        gfx.paint(screen);\n      }\n    };\n\n    /**\n     * Once started the animateLoop function will call itself recursively\n     */\n\n    this.frame = requestAnimationFrame(animateLoop);\n  }\n\n  stop() {\n    cancelAnimationFrame(this.frame);\n  }\n}\n","import { useState, useEffect, useRef } from 'react';\nimport { Field, Form, Formik } from 'formik';\nimport request from 'axios';\nimport isClient from '@bagofholding/is-client';\n\nimport Chip from '../../libs/chip/chip';\n\nimport './App.scss';\n\nfunction App() {\n  const [booted, setBooted] = useState(false);\n  const canvas = useRef(null);\n\n  const config = { fps: 60 };\n  const { fps } = config;\n  const [state, setState] = useState(config);\n\n  useEffect(() => {\n    async function fetchData() {\n      setBooted(true);\n      /**\n       * sadly superagent does not support blobs in userland\n       * we have retired it here in favour of axios\n       */\n      const response = await request({\n        url: `${process.env.PUBLIC_URL}/roms/pong`,\n        method: 'GET',\n        responseType: 'blob'\n      });\n\n      const blob = new Blob([response.data]);\n      const buffer = await blob.arrayBuffer();\n      const rom = new Uint8Array(buffer);\n      const chip = new Chip(rom, canvas, fps);\n\n      window.chip = chip;\n    }\n\n    if (booted) {\n      return;\n    }\n\n    if (isClient() && canvas && canvas?.current) {\n      fetchData();\n    }\n  }, [booted, canvas, fps]);\n\n  return (\n    <div className=\"container app\">\n      <div className=\"row\">\n        <div className=\"col-12 text-center\">\n          <h1>CHIP.ts</h1>\n          <canvas data-testid=\"canvas\" ref={canvas} />\n        </div>\n      </div>\n\n      <Formik\n        initialValues={{ ...state }}\n        onSubmit={values => setState(values)}\n      >\n        <Form className=\"row g-3 justify-content-lg-center\">\n          <div className=\"col-2 text-center form-floating\">\n            <Field\n              className=\"form-control\"\n              type=\"number\"\n              name=\"fps\"\n              id=\"fps\"\n              min=\"0\"\n            />\n            <label htmlFor=\"fps\" className=\"text-dark\">\n              Frame rate\n            </label>\n          </div>\n          <div className=\"col-2 text-center\">\n            <button className=\"btn btn-primary\" type=\"submit\">\n              Submit\n            </button>\n          </div>\n        </Form>\n      </Formik>\n    </div>\n  );\n}\n\ndeclare global {\n  interface Window {\n    chip: Chip;\n  }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './containers/App/App';\n\nimport reportWebVitals from './reportWebVitals';\n\nimport './sass/index.scss';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}