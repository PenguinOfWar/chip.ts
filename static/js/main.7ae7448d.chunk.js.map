{"version":3,"sources":["libs/chip/drivers/cpu.ts","libs/chip/drivers/gfx.ts","libs/chip/chip.ts","containers/App/App.tsx","reportWebVitals.ts","index.tsx"],"names":["Cpu","rom","memory","Uint8Array","ArrayBuffer","registers","stack","Uint16Array","stackPointer","counter","this","load","map","instruction","address","addressMap","opcode","x","y","console","log","Gfx","canvas","context","resolution","scale","screen","current","boot","getContext","width","height","disp_clear","clearRect","pixel","position","Math","floor","fillStyle","fillRect","Chip","fps","frame","start","cpu","gfx","then","performance","now","interval","paint","requestAnimationFrame","animateLoop","delta","tick","cancelAnimationFrame","App","useState","booted","setBooted","useRef","useEffect","a","request","url","process","method","responseType","response","blob","Blob","data","arrayBuffer","buffer","chip","isClient","fetchData","className","data-testid","ref","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7ae7448d.chunk.js","sourcesContent":["/**\n *\n * CHIP-8 CPU emulator class\n * @author Darryl Walker\n *\n */\n\nexport default class Cpu {\n  /**\n   * CHIP-8 has 4096 8-bit (1 byte) memory locations\n   * A byte is normally the smallest addressable location\n   * Each byte can be a value of 0-255\n   *\n   * Our 4096 decimal can expressed as 0x1000 in hexadecimal\n   * We will create a new ArrayBuffer and pass it to Uint8Array (unsigned integer with a range of 0-255)\n   * Array buffer will handle our raw data for us e.g. 0x1000 => 4096\n   */\n\n  memory = new Uint8Array(new ArrayBuffer(0x1000));\n\n  /**\n   * CHIP-8 has 16 8-bit data registers named V0 to VF\n   * We create a new Uint8Array with 16 register locations\n   */\n\n  registers = new Uint8Array(16);\n\n  /**\n   * Our stack will need to store return addresses\n   * We will need 16 of these 16-bit addresses\n   */\n\n  stack = new Uint16Array(16);\n\n  /**\n   * Our stack pointer will store where in our 16 length stack we should be\n   */\n\n  stackPointer = 0;\n\n  /**\n   * We need to define our program counter\n   * This is the next instruction that should be executed by our cpu\n   * CHIP-8 starts at 0x200 leaving the lowest 512 bytes (0-511) free\n   * We'll store font data there later\n   */\n\n  counter = 0x200;\n\n  constructor(rom: Uint8Array) {\n    this.load(rom);\n  }\n\n  /**\n   * We take the ROM file represented as a Uint8Array and map into memory\n   * Here we need to ecounter for the original interpreter positions\n   * For this reason, most programs written for the original system begin at memory location 512 (0x200)\n   * We shift all the memory addresses over by 512 (or 0x200 for fun)\n   */\n\n  load(rom: Uint8Array) {\n    rom.map((instruction, address) => {\n      /**\n       * take the instrction and the array index as our memory address\n       * map this into our emulators memory\n       */\n\n      const addressMap = address + 0x200;\n\n      this.memory[addressMap] = instruction;\n\n      return instruction;\n    });\n  }\n\n  /**\n   * Our processor will perform an instruction once per tick\n   * During this time we will check the opcode and see what it needs to do\n   */\n\n  public tick() {\n    /**\n     * This bit is a little confusing to me\n     * I learned a lot of it from reading\n     * https://github.com/alexanderdickson/Chip-8-Emulator/blob/5da6ac6a4753462d02ca7fe8d5a9398308b8d9d0/scripts/chip8.js#L193\n     * We're shifting everything over bitwise 8 to the left\n     * And then doing a bitwise or on each pair of bits. a OR b yields 1 if either a or b is 1.\n     *\n     * UPDATE\n     * Bless this dude, who seems to be the reference for the above JS dude/dudette\n     * https://github.com/eshyong/Chip-8-Emulator/blob/master/chip8.c\n     *\n     * Opcodes are two bytes long!\n     * We're creating a hexidecimal here, I guess? Out of the two byte opcode\n     *\n     * here we take the first complete bite\n     * in pongs case that's 6A hex / 106 decimal√é\n     * we also take the next byte which is conveniently 02 hex / 2 decimal\n     *\n     * fuck me\n     * i guess this is a clever way of storing integers greater than 8 bits\n     * which is cool as shit\n     *\n     * we take decimal 106 and we shift it left 8 places giving us decimal 27136\n     *\n     * then we take output of that left shift and give it to a bitwise OR - the single pipe dude\n     * this guy adds them together\n     * problem: 27136 | 2\n     * result: 27138 decimal / 6a02 hex\n     *\n     * i guess we just got two bytes of storage out of one byte of data\n     * how very... bitwise\n     *\n     */\n\n    const opcode =\n      (this.memory[this.counter] << 8) | this.memory[this.counter + 1];\n\n    /**\n     * here a bitwise AND (&) compares two numbers and casts them to numbers if they arent numbers\n     * my head hurts\n     *\n     * Read here:\n     * https://en.wikipedia.org/wiki/Bitwise_operation#AND\n     *\n     * Okay.\n     * There's a lot going on here.\n     * X is a two parter, first we take our opcode 27136 and give it 0x0f00 hex / 3840 decimal\n     * this yields a00 hex / 2560 decimal\n     *\n     * we then shift the result over 8 places right yielding a hex / 10 decimal\n     * giving us our register address for later!\n     *\n     * do similar for y taking 27136 and giving it 0x0000 hex / 0 decimal and go god i keep flopping back and forth\n     * it's all hex i swear just different hex and i will tidy it up just look at the decimals\n     *\n     * shift it over 4 and it's still 0 / 0x0000\n     *\n     */\n\n    const x = (opcode & 0x0f00) >> 8;\n    const y = (opcode & 0x00f0) >> 4;\n\n    if (opcode === 27138) {\n      console.log(27138, opcode & 0x0f00, x);\n      console.log(27138, opcode & 0x00f0, y);\n    }\n\n    /**\n     * all of our instructions are two bytes long\n     * increment our counter+2 to move to the next instruction by default\n     */\n\n    this.counter += 2;\n\n    /**\n     * then start checking opcodes\n     *\n     * our first check is the result of opcode AND 0xf000\n     * continuing with the above we have 27138 & 61440 = 24576 decimal / 0x6000 hex\n     *\n     * this corresponds to opcode 6XNN!\n     * https://en.wikipedia.org/wiki/CHIP-8#Opcode_table\n     *\n     * this is called checking the first nibble of the byte\n     */\n\n    switch (opcode & 0xf000) {\n      /**\n       * This can be a few things but we only really care about two of them - 00E0 and 00EE\n       */\n      case 0x0000: {\n        switch (opcode) {\n          /**\n           * 00E0 / disp_clear() - clears the screen\n           */\n          case 0x00e0:\n            // this.renderer.clear();\n            // for (var i = 0; i < this.display.length; i++) {\n            //   this.display[i] = 0;\n            // }\n            console.log('Render clear');\n            break;\n\n          // RET\n          // 00EE\n          // Return from subroutine.\n          case 0x00ee:\n            // this.pc = this.stack[--this.sp];\n            console.log('Return from subroutine');\n            break;\n        }\n        break;\n      }\n      /**\n       * 6XNN - Sets VX to NN\n       * opcode AND 0xFF hex / 255 dec = 2 dec / 02 hex\n       * therefore register 10 now has a value of two\n       */\n      case 0x6000: {\n        console.log('Setting VX to NN', x, opcode & 0xff);\n        this.registers[x] = opcode & 0xff;\n        break;\n      }\n      default: {\n        // throw new Error(`Unknown opcode: ${opcode.toString(16)}`);\n      }\n    }\n  }\n}\n","/**\n *\n * CHIP.ts canvas render methods\n * @author Darryl Walker\n *\n */\n\nexport default class Gfx {\n  /**\n   * This class will receive input from a buffer and draw a new screen\n   * Canvas is convenient and cool so we'll use that\n   */\n\n  canvas: any = null;\n  context: CanvasRenderingContext2D | null = null;\n\n  /**\n   * Here we configure graphics information\n   * CHIP-8 has a display resolution of 64x32 and we'll scale it up 8 times\n   * Our poor renderer is bound to his resolution forever :(\n   */\n\n  public resolution = {\n    x: 64,\n    y: 32,\n    scale: 8\n  };\n\n  /**\n   * Our screen space will be an array representing pixels\n   * left to right, top to bottom, 8-bits (1-byte) each\n   */\n\n  public screen = new Uint8Array(this.resolution.x * this.resolution.y);\n\n  /**\n   * giving up and resorting to any type\n   * seems to work now\n   * we'll assign our canvas to a local property\n   */\n\n  constructor(canvas: any) {\n    this.canvas = canvas.current;\n    this.boot();\n  }\n\n  /**\n   * Some basic canvas stuff here we're going to get a 2d canvas context\n   * we're going to give the canvas height and width dimension * scale\n   */\n\n  boot() {\n    this.context = this.canvas.getContext('2d');\n    this.canvas.width = this.resolution.x * this.resolution.scale;\n    this.canvas.height = this.resolution.y * this.resolution.scale;\n\n    this.disp_clear();\n  }\n\n  disp_clear() {\n    /**\n     * man i cannot get typescript to shut the fuck about how this might be null\n     * look at all this extra code\n     * i love typescript but she doesnt make it easy\n     */\n    this.context?.clearRect &&\n      this.context.clearRect(\n        0,\n        0,\n        this.resolution.x * this.resolution.scale,\n        this.resolution.y * this.resolution.scale\n      );\n  }\n\n  public paint() {\n    /**\n     * Start every render by clearing the screen\n     */\n    this.disp_clear();\n\n    if (this.context) {\n      const context = this.context;\n      const resolution = this.resolution;\n\n      this.screen.map((pixel, position) => {\n        const x = (position % resolution.x) * resolution.scale;\n        const y = Math.floor(position / resolution.x) * resolution.scale;\n\n        context.fillStyle = ['#000', '#00ff00'][pixel];\n        context.fillRect(x, y, this.resolution.scale, this.resolution.scale);\n        return pixel;\n      });\n    }\n  }\n}\n","/**\n *\n * CHIP.ts - A CHIP-8 emulator in TypeScript\n * @author Darryl Walker\n *\n */\n\nimport Cpu from './drivers/cpu';\nimport Gfx from './drivers/gfx';\n\nexport default class Chip {\n  /**\n   * Configure our preferred target framerate\n   * We'll also configure our frame pointer and play state\n   * Timing function from https://gist.github.com/addyosmani/5434533#gistcomment-2018050\n   */\n\n  fps = 60;\n  frame = 0;\n\n  /**\n   * i couldnt figure out how to make typescript happy with canvas so i've checked it can't be null up the chain - bit risky tho\n   *\n   * @param rom - a CHIP-8 rom file as a Uint8Array\n   * @param canvas - an html canvas element for our renderer\n   */\n\n  constructor(rom: Uint8Array, canvas: any) {\n    this.start(new Cpu(rom), new Gfx(canvas));\n  }\n\n  /**\n   * start will kick off our timing function\n   * this is going to check 60 times per second\n   * requestAnimationFrame is a browser API that helps us\n   * with render timing\n   */\n\n  start(cpu: Cpu, gfx: Gfx) {\n    /**\n     * I just learned about performance\n     * This is cool\n     */\n\n    let then: number = performance.now();\n\n    const interval = 1000 / this.fps;\n    const tolerance = 0.1;\n\n    const animateLoop = (now: number) => {\n      this.frame = requestAnimationFrame(animateLoop);\n\n      const delta = now - then;\n\n      if (delta >= interval - tolerance) {\n        then = now - (delta % interval);\n\n        /**\n         * Code within this block is executed once per frame\n         */\n\n        cpu.tick();\n        // gfx.paint();\n      }\n    };\n\n    /**\n     * Once started the animateLoop function will call itself recursively\n     */\n\n    gfx.paint();\n    this.frame = requestAnimationFrame(animateLoop);\n  }\n\n  stop() {\n    cancelAnimationFrame(this.frame);\n  }\n}\n","import { useState, useEffect, useRef } from 'react';\nimport isClient from '@bagofholding/is-client';\n\nimport request from 'axios';\n\nimport Chip from '../../libs/chip/chip';\n\nimport './App.scss';\n\nfunction App() {\n  const [booted, setBooted] = useState(false);\n  const canvas = useRef(null);\n\n  useEffect(() => {\n    async function fetchData() {\n      setBooted(true);\n      /**\n       * sadly superagent does not support blobs in userland\n       * we have retired it here in favour of axios\n       */\n      const response = await request({\n        url: `${process.env.PUBLIC_URL}/roms/pong`,\n        method: 'GET',\n        responseType: 'blob'\n      });\n\n      const blob = new Blob([response.data]);\n      const buffer = await blob.arrayBuffer();\n      const rom = new Uint8Array(buffer);\n      const chip = new Chip(rom, canvas);\n\n      console.log(chip);\n    }\n\n    if (booted) {\n      return;\n    }\n\n    if (isClient() && canvas && canvas?.current) {\n      fetchData();\n    }\n  }, [booted, canvas]);\n\n  return (\n    <div className=\"container app\">\n      <div className=\"row\">\n        <div className=\"col-12\">\n          <h1>CHIP.ts</h1>\n          <canvas data-testid=\"canvas\" ref={canvas} />\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './containers/App/App';\n\nimport reportWebVitals from './reportWebVitals';\n\nimport './sass/index.scss';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}