{"version":3,"sources":["libs/chip/assets/characters.ts","libs/chip/drivers/cpu.ts","libs/chip/drivers/gfx.ts","libs/chip/drivers/keyboard.ts","libs/chip/chip.ts","containers/App/App.tsx","reportWebVitals.ts","index.tsx"],"names":["fonts","Cpu","rom","gfx","memory","Uint8Array","ArrayBuffer","registers","stack","Uint16Array","stackPointer","counter","pointer","screen","delayTimer","soundTimer","keys","key","running","this","resolution","x","y","load","loadFont","map","instruction","address","addressMap","start","char","index","tick","opcode","NN","JUMP","didJump","disp_clear","console","warn","Error","toString","Math","floor","random","spr","height","coordinates","vertical","horizontal","scale","setPixel","stop","pointers","i","width","location","display","Gfx","canvas","colors","background","foreground","context","grid","current","boot","getContext","clearRect","pixel","position","fillStyle","strokeStyle","fillRect","strokeRect","Keyboard","cpu","listen","input","document","addEventListener","event","press","release","Chip","speed","frame","keyboard","working","setInterval","next","requestAnimationFrame","animateLoop","paint","cancelAnimationFrame","App","useRef","games","instructions","brix","tetris","pong","useState","toLowerCase","slot","setSlot","fetchData","useCallback","a","request","url","process","method","responseType","response","blob","Blob","data","arrayBuffer","buffer","chip","window","useEffect","isClient","handleButtonPress","setTimeout","className","data-testid","ref","onClick","toggleGrid","row","column","toUpperCase","role","initialValues","onSubmit","values","as","name","game","value","type","href","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.31fd4f1d.chunk.js","sourcesContent":["export const fonts = [\n  0xf0,\n  0x90,\n  0x90,\n  0x90,\n  0xf0, // 0\n  0x20,\n  0x60,\n  0x20,\n  0x20,\n  0x70, // 1\n  0xf0,\n  0x10,\n  0xf0,\n  0x80,\n  0xf0, // 2\n  0xf0,\n  0x10,\n  0xf0,\n  0x10,\n  0xf0, // 3\n  0x90,\n  0x90,\n  0xf0,\n  0x10,\n  0x10, // 4\n  0xf0,\n  0x80,\n  0xf0,\n  0x10,\n  0xf0, // 5\n  0xf0,\n  0x80,\n  0xf0,\n  0x90,\n  0xf0, // 6\n  0xf0,\n  0x10,\n  0x20,\n  0x40,\n  0x40, // 7\n  0xf0,\n  0x90,\n  0xf0,\n  0x90,\n  0xf0, // 8\n  0xf0,\n  0x90,\n  0xf0,\n  0x10,\n  0xf0, // 9\n  0xf0,\n  0x90,\n  0xf0,\n  0x90,\n  0x90, // A\n  0xe0,\n  0x90,\n  0xe0,\n  0x90,\n  0xe0, // B\n  0xf0,\n  0x80,\n  0x80,\n  0x80,\n  0xf0, // C\n  0xe0,\n  0x90,\n  0x90,\n  0x90,\n  0xe0, // D\n  0xf0,\n  0x80,\n  0xf0,\n  0x80,\n  0xf0, // E\n  0xf0,\n  0x80,\n  0xf0,\n  0x80,\n  0x80 // F\n];\n","/**\n *\n * CHIP-8 CPU emulator class\n * @author Darryl Walker\n *\n */\n\nimport Gfx from './gfx';\nimport { fonts } from '../assets/characters';\n\nexport default class Cpu {\n  /**\n   * CHIP-8 has 4096 8-bit (1 byte) memory locations\n   * A byte is normally the smallest addressable location\n   * Each byte can be a value of 0-255\n   *\n   * Our 4096 decimal can expressed as 0x1000 in hexadecimal\n   * We will create a new ArrayBuffer and pass it to Uint8Array (unsigned integer with a range of 0-255)\n   * Array buffer will handle our raw data for us e.g. 0x1000 => 4096\n   */\n\n  memory = new Uint8Array(new ArrayBuffer(0x1000));\n\n  /**\n   * CHIP-8 has 16 8-bit data registers named V0 to VF\n   * We create a new Uint8Array with 16 register locations\n   */\n\n  registers = new Uint8Array(16);\n\n  /**\n   * Our stack will need to store return addresses\n   * We will need 16 of these 16-bit addresses\n   */\n\n  stack = new Uint16Array(16);\n\n  /**\n   * Our stack pointer will store where in our 16 length stack we should be\n   */\n\n  stackPointer = 0;\n\n  /**\n   * We need to define our program counter\n   * This is the next instruction that should be executed by our cpu\n   * CHIP-8 starts at 0x200 leaving the lowest 512 bytes (0-511) free\n   * We'll store font data there later\n   */\n\n  counter = 0x200;\n\n  /**\n   * Assign a position for our graphics adapter\n   */\n\n  gfx;\n\n  /**\n   * okay so this is a pointer i've called pointer\n   * in reality it's confusingly called \"I\"\n   * i like mine better for now\n   * on the CHIP-8 it's a 16-bit register so a regular number is fine\n   */\n\n  pointer = 0;\n\n  /**\n   * Our screen space will be an array representing pixels\n   * left to right, top to bottom, 8-bits (1-byte) each\n   */\n\n  public screen = new Uint8Array();\n\n  /**\n   * we have two timers- one for delay and one for sound\n   */\n\n  delayTimer = 0;\n  soundTimer = 0;\n\n  /**\n   * Keypad - used as input from a HEX keypad\n   */\n\n  keys: IKeys = {};\n\n  /**\n   * at any given time we can have one key pressed\n   * so we'll keep track of it via a pointer\n   */\n\n  key = 0;\n\n  /**\n   * We need a way to track whether or not ops should be paused\n   * a boolean will do\n   */\n\n  public running = false;\n\n  constructor(rom: Uint8Array, gfx: Gfx) {\n    this.gfx = gfx;\n    this.screen = new Uint8Array(this.gfx.resolution.x * this.gfx.resolution.y);\n    this.load(rom);\n  }\n\n  /**\n   * We take the ROM file represented as a Uint8Array and map into memory\n   * Here we need to ecounter for the original interpreter positions\n   * For this reason, most programs written for the original system begin at memory location 512 (0x200)\n   * We shift all the memory addresses over by 512 (or 0x200 for fun)\n   */\n\n  load(rom: Uint8Array) {\n    /**\n     * load fonts first\n     */\n\n    this.loadFont();\n\n    rom.map((instruction, address) => {\n      /**\n       * take the instrction and the array index as our memory address\n       * map this into our emulators memory\n       */\n\n      const addressMap = address + 0x200;\n\n      this.memory[addressMap] = instruction;\n\n      return instruction;\n    });\n\n    /**\n     * it's always useful if you remember to start the engine\n     */\n    this.start();\n  }\n\n  /**\n   * We need to load a hexadecimal character set into the first few bytes of our memory\n   * we have 512 free slots to play with in total\n   */\n  loadFont() {\n    return fonts.map((char, index) => {\n      return (this.memory[index] = char);\n    });\n  }\n\n  public start() {\n    this.running = true;\n  }\n\n  public stop() {\n    this.running = false;\n  }\n\n  /**\n   * We will provided a handle little API for the chip to call for a tick at the preferred rate\n   * next will check if the cpu is running and tick if true\n   */\n\n  public next() {\n    if (!this.running) {\n      return;\n    }\n\n    this.tick();\n  }\n\n  /**\n   * Our processor will perform an instruction once per tick\n   * During this time we will check the opcode and see what it needs to do\n   */\n\n  tick() {\n    /**\n     * before we do anything we have to decrement our timers\n     */\n\n    if (this.delayTimer > 0) {\n      --this.delayTimer;\n    }\n\n    if (this.soundTimer > 0) {\n      --this.soundTimer;\n    }\n\n    /**\n     * This bit is a little confusing to me\n     * I learned a lot of it from reading\n     * https://github.com/alexanderdickson/Chip-8-Emulator/blob/5da6ac6a4753462d02ca7fe8d5a9398308b8d9d0/scripts/chip8.js#L193\n     * We're shifting everything over bitwise 8 to the left\n     * And then doing a bitwise or on each pair of bits. a OR b yields 1 if either a or b is 1.\n     *\n     * UPDATE\n     * Bless this dude, who seems to be the reference for the above JS dude/dudette\n     * https://github.com/eshyong/Chip-8-Emulator/blob/master/chip8.c\n     *\n     * Opcodes are two bytes long!\n     * We're creating a hexidecimal here, I guess? Out of the two byte opcode\n     *\n     * here we take the first complete bite\n     * in pongs case that's 6A hex / 106 decimal√é\n     * we also take the next byte which is conveniently 02 hex / 2 decimal\n     *\n     * fuck me\n     * i guess this is a clever way of storing integers greater than 8 bits\n     * which is cool as shit\n     *\n     * we take decimal 106 and we shift it left 8 places giving us decimal 27136\n     *\n     * then we take output of that left shift and give it to a bitwise OR - the single pipe dude\n     * this guy adds them together\n     * problem: 27136 | 2\n     * result: 27138 decimal / 6a02 hex\n     *\n     * i guess we just got two bytes of storage out of one byte of data\n     * how very... bitwise\n     *\n     */\n\n    const opcode =\n      (this.memory[this.counter] << 8) | this.memory[this.counter + 1];\n\n    /**\n     * here a bitwise AND (&) compares two numbers and casts them to numbers if they arent numbers\n     * my head hurts\n     *\n     * Read here:\n     * https://en.wikipedia.org/wiki/Bitwise_operation#AND\n     *\n     * Okay.\n     * There's a lot going on here.\n     * X is a two parter, first we take our opcode 27136 and give it 0x0f00 hex / 3840 decimal\n     * this yields a00 hex / 2560 decimal\n     *\n     * we then shift the result over 8 places right yielding a hex / 10 decimal\n     * giving us our register address for later!\n     *\n     * do similar for y taking 27136 and giving it 0x0000 hex / 0 decimal and go god i keep flopping back and forth\n     * it's all hex i swear just different hex and i will tidy it up just look at the decimals\n     *\n     * shift it over 4 and it's still 0 / 0x0000\n     *\n     */\n\n    const x = (opcode & 0x0f00) >> 8;\n    const y = (opcode & 0x00f0) >> 4;\n    const NN = opcode & 0x00ff;\n    const JUMP = opcode & 0x0fff;\n    let didJump = false;\n\n    /**\n     * then start checking opcodes\n     *\n     * our first check is the result of opcode AND 0xf000\n     * continuing with the above we have 27138 & 61440 = 24576 decimal / 0x6000 hex\n     *\n     * this corresponds to opcode 6XNN!\n     * https://en.wikipedia.org/wiki/CHIP-8#Opcode_table\n     *\n     * this is called checking the first nibble of the byte\n     */\n\n    switch (opcode & 0xf000) {\n      /**\n       * 0000\n       * This can be a few things but we only really care about two of them - 00E0 and 00EE\n       */\n      case 0x0000: {\n        switch (opcode) {\n          /**\n           * 00E0 / disp_clear() - clears the screen\n           */\n          case 0x00e0:\n            this.gfx.disp_clear();\n            break;\n\n          /**\n           * 00EE / return from a subroutine\n           */\n          case 0x00ee:\n            if (this.stack[this.stackPointer] === 0) {\n              console.warn('Invalid return from subroutine.');\n            }\n\n            this.counter = this.stack[this.stackPointer];\n            this.stack[this.stackPointer] = 0;\n\n            if (this.stackPointer > 0) {\n              --this.stackPointer;\n            }\n            break;\n        }\n        break;\n      }\n\n      /**\n       * 1NNN - Jumps to address NNN.\n       */\n      case 0x1000: {\n        this.counter = JUMP;\n        didJump = true;\n        break;\n      }\n\n      /**\n       * 2NNN - Calls subroutine at NNN.\n       * Updates the counter to the next instruction\n       * We store the return address for later and increment our stack size\n       */\n      case 0x2000: {\n        if (this.stack[this.stackPointer] !== 0) {\n          ++this.stackPointer;\n        }\n        this.stack[this.stackPointer] = this.counter;\n        this.counter = JUMP;\n        didJump = true;\n        break;\n      }\n\n      /**\n       * 3XNN/if(Vx==NN) - Skips the next instruction if VX equals NN. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x3000: {\n        if (this.registers[x] === NN) {\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * 4XNN/if(Vx!=NN - Skips the next instruction if VX doesn't equal NN. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x4000: {\n        if (this.registers[x] !== NN) {\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * 5XY0/if(Vx==Vy) - Skips the next instruction if VX equals VY. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x5000: {\n        if (this.registers[x] === this.registers[y]) {\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * 6XNN - Sets VX to NN\n       * opcode AND 0xFF hex / 255 dec = 2 dec / 02 hex\n       * therefore register 10 now has a value of two\n       */\n      case 0x6000: {\n        this.registers[x] = opcode & 0xff;\n        break;\n      }\n\n      /**\n       * 7XNN - Adds NN to VX. (Carry flag is not changed)\n       */\n      case 0x7000: {\n        this.registers[x] += NN;\n        break;\n      }\n\n      /**\n       * 8000 is an imposing list of VX and VY operations\n       */\n\n      case 0x8000: {\n        switch (opcode & 0x000f) {\n          /**\n           * 8XY0/Vx=Vy - Sets VX to the value of VY.\n           */\n          case 0x0000: {\n            this.registers[x] = this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY1/Vx=Vx|Vy - Sets VX to VX or VY. (Bitwise OR operation)\n           */\n          case 0x0001: {\n            this.registers[x] = this.registers[x] | this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY2/Vx=Vx&Vy - Sets VX to VX and VY. (Bitwise AND operation)\n           */\n          case 0x0002: {\n            this.registers[x] = this.registers[x] & this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY3/Vx=Vx^Vy - Sets VX to VX xor VY.\n           */\n          case 0x0003: {\n            this.registers[x] = this.registers[x] ^ this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY4/Vx += Vy - Adds VY to VX. VF is set to 1 when there's a carry, and to 0 when there isn't.\n           */\n          case 0x0004: {\n            if (this.registers[x] + this.registers[y] > 255) {\n              this.registers[0xf] = 1;\n            } else {\n              this.registers[0xf] = 0;\n            }\n            this.registers[x] += this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY5/Vx -= Vy - VY is subtracted from VX. VF is set to 0 when there's a borrow, and 1 when there isn't.\n           */\n          case 0x0005: {\n            if (this.registers[x] < this.registers[y]) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] -= this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY6/Vx>>=1 - Stores the least significant bit of VX in VF and then shifts VX to the right by 1.\n           */\n          case 0x0006: {\n            if (this.registers[x] % 2 === 0) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] = this.registers[x] >> 1;\n            break;\n          }\n\n          /**\n           * 8XY7/Vx=Vy-Vx - Sets VX to VY minus VX. VF is set to 0 when there's a borrow, and 1 when there isn't.\n           */\n          case 0x0007: {\n            if (this.registers[y] < this.registers[x]) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] = this.registers[y] - this.registers[x];\n            break;\n          }\n\n          /**\n           * 8XYE/Vx<<=1 - Stores the most significant bit of VX in VF and then shifts VX to the left by 1\n           */\n          case 0x000e: {\n            if (this.registers[x] < 128) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] = this.registers[x] << 1;\n            break;\n          }\n          default: {\n            throw new Error(\n              `Unknown opcode in 8000 block: ${opcode.toString(16)}`\n            );\n          }\n        }\n        break;\n      }\n\n      /**\n       * we (i) forgot about instruction 9\n       * 9XY0/if(Vx!=Vy) - Skips the next instruction if VX doesn't equal VY. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x9000: {\n        // skip next instruction if VX not equals VY\n        if (this.registers[x] !== this.registers[y]) {\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * ANNN - Sets pointer/I to address NNN\n       */\n      case 0xa000: {\n        this.pointer = JUMP;\n        break;\n      }\n\n      /**\n       * BNNN - Jumps to addres that is sum of NNN and V0 (register 0)\n       */\n      case 0xb000: {\n        this.counter = (opcode & 0xfff) + this.registers[0];\n        didJump = true;\n        break;\n      }\n\n      /**\n       * CXNN/Vx=rand()&N - Sets VX to the result of a bitwise and operation on a random number (Typically: 0 to 255) and NN.\n       */\n      case 0xc000: {\n        this.registers[x] = Math.floor(Math.random() * 255) % 255 & NN;\n        break;\n      }\n\n      /**\n       * DXYN / draw(Vx,Vy,N) - Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N+1 pixels.\n       */\n      case 0xd000: {\n        const height = opcode & 0x000f;\n\n        /**\n         * get our x and y coordinates from our register\n         * use values at position VX and VY\n         */\n\n        let coordinates: ICoordinates = {\n          x: this.registers[x],\n          y: this.registers[y]\n        };\n\n        // set carry flag to 0\n        this.registers[0xf] = 0;\n\n        let spr;\n\n        /**\n         * drawing loop\n         * try not to get it backwards like i did\n         */\n        for (let vertical = 0; vertical < height; vertical++) {\n          spr = this.memory[this.pointer + vertical];\n\n          for (\n            let horizontal = 0;\n            horizontal < this.gfx.resolution.scale;\n            horizontal++\n          ) {\n            if (coordinates.x + horizontal === this.gfx.resolution.x) {\n              coordinates.x = -horizontal;\n            }\n            if (coordinates.y + vertical === this.gfx.resolution.y) {\n              coordinates.y = -vertical;\n            }\n\n            if ((spr & 0x80) > 0) {\n              if (\n                this.setPixel(\n                  this.registers[x] + horizontal,\n                  this.registers[y] + vertical\n                )\n              ) {\n                this.registers[0xf] = 1;\n              }\n            }\n            spr <<= 1;\n          }\n          coordinates.x = this.registers[x];\n          coordinates.y = this.registers[y];\n        }\n\n        break;\n      }\n\n      /**\n       * E000 can be one of two things, both bound to key presses\n       * they are kind of the opposite of one another\n       */\n      case 0xe000: {\n        switch (NN) {\n          /**\n           * EX9E/if(key()==Vx) - Skips the next instruction if the key stored in VX is pressed. (Usually the next instruction is a jump to skip a code block)\n           */\n          case 0x009e: {\n            if (this.key === this.registers[x]) {\n              this.counter += 2;\n            }\n            break;\n          }\n\n          /**\n           * EXA1/if(key()!=Vx) - Skips the next instruction if the key stored in VX isn't pressed. (Usually the next instruction is a jump to skip a code block)\n           */\n          case 0x00a1: {\n            if (this.key !== this.registers[x]) {\n              this.counter += 2;\n            }\n            break;\n          }\n          default: {\n            throw new Error(\n              `Unknown opcode in e000 block: ${opcode.toString(16)}`\n            );\n          }\n        }\n        break;\n      }\n\n      /**\n       * ol mate F000 can be a few things\n       */\n      case 0xf000: {\n        switch (NN) {\n          /**\n           * FX07/get_delay() -\tSets VX to the value of the delay timer.\n           */\n          case 0x0007: {\n            this.registers[x] = this.delayTimer;\n            break;\n          }\n          /**\n           * FX0A/get_key() - A key press is awaited, and then stored in VX. (Blocking Operation. All instruction halted until next key event)\n           * What this means is we are actually going to halt the program and wait until a key is pressed\n           */\n          case 0x000a: {\n            if (this.key === 0) {\n              this.stop();\n              return;\n            } else {\n              this.registers[x] = this.key;\n              this.start();\n            }\n            break;\n          }\n\n          /**\n           * FX15/delay_timer(Vx) - Sets the delay timer to VX.\n           */\n          case 0x0015: {\n            this.delayTimer = this.registers[x];\n            break;\n          }\n\n          /**\n           * FX18/sound_timer(Vx) - Sets the sound timer to VX.\n           */\n          case 0x0018: {\n            this.soundTimer = this.registers[x];\n            break;\n          }\n\n          /**\n           * X1E - Adds VX to pointer/I. VF is not affected\n           */\n          case 0x001e: {\n            this.pointer += this.registers[x];\n            break;\n          }\n\n          /**\n           * FX29 - I=sprite_addr[Vx] - Sets I to the location of the sprite for the character in VX.\n           * Characters 0-F (in hexadecimal) are represented by a 4x5 font.\n           * we multiply by 5 to get there\n           */\n          case 0x0029: {\n            this.pointer = this.registers[x] * 5;\n            break;\n          }\n\n          /**\n           * FX33/set_BCD - Stores the binary-coded decimal representation of VX, with the most significant of\n           * three digits at the address in I, the middle digit at I plus 1, and the least significant digit at\n           * I plus 2. (In other words, take the decimal representation of VX, place the hundreds digit in memory\n           * at location in I, the tens digit at location I+1, and the ones digit at location I+2.)\n           */\n          case 0x0033: {\n            const pointers = [\n              this.registers[x] / 100,\n              (this.registers[x] / 10) % 10,\n              this.registers[x] % 10\n            ];\n            this.memory[this.pointer] = pointers[0];\n            this.memory[this.pointer + 1] = pointers[1];\n            this.memory[this.pointer + 2] = pointers[2];\n            break;\n          }\n\n          /**\n           * FX55/reg_dump(Vx,&I) - Stores V0 to VX (including VX) in memory starting at address I.\n           */\n          case 0x0055: {\n            for (let i = 0; i <= x; i++) {\n              this.memory[this.pointer + i] = this.registers[i];\n            }\n            break;\n          }\n\n          /**\n           * FX65/reg_load(Vx,&I) - Fills V0 to VX (including VX) with values from memory starting at address I.\n           */\n          case 0x0065: {\n            for (let i = 0; i <= x; i++) {\n              this.registers[i] = this.memory[this.pointer + i];\n            }\n            this.pointer = this.pointer + x + 1;\n            break;\n          }\n        }\n        break;\n      }\n      default: {\n        throw new Error(`Unknown opcode: ${opcode.toString(16)}`);\n      }\n    }\n\n    /**\n     * all of our instructions are two bytes long\n     * increment our counter+2 to move to the next instruction by default\n     */\n\n    if (!didJump) {\n      this.counter += 2;\n    }\n  }\n\n  get display() {\n    return this.screen;\n  }\n\n  /**\n   * do our set pixel handling here\n   */\n  setPixel(x: number, y: number) {\n    const width = this.gfx.resolution.x;\n    const height = this.gfx.resolution.y;\n\n    // If the pixel exceeds the dimensions,\n    // wrap it back around.\n    if (x > width) {\n      x -= width;\n    } else if (x < 0) {\n      x += width;\n    }\n\n    if (y > height) {\n      y -= height;\n    } else if (y < 0) {\n      y += height;\n    }\n\n    const location = x + y * width;\n\n    this.display[location] ^= 1;\n\n    return !this.screen[location];\n  }\n\n  /**\n   * provide a public api for the keyboard drive to update the key pressed\n   */\n  public input(key: any) {\n    this.key = key;\n  }\n}\n\nexport interface ICoordinates {\n  x: number;\n  y: number;\n}\n\nexport interface IKeys {\n  [key: number]: any;\n}\n","/**\n *\n * CHIP.ts canvas render methods\n * @author Darryl Walker\n *\n */\n\nexport default class Gfx {\n  /**\n   * we get 2 whole colours to play with here\n   * our background will be black and our foreground classic monochrome green\n   */\n\n  colors = {\n    background: '#000',\n    foreground: '#00ff00'\n  };\n\n  /**\n   * This class will receive input from a buffer and draw a new screen\n   * Canvas is convenient and cool so we'll use that\n   */\n\n  canvas: any = null;\n  context: CanvasRenderingContext2D | null = null;\n  grid = false;\n\n  /**\n   * Here we configure graphics information\n   * CHIP-8 has a display resolution of 64x32 and we'll scale it up 8 times\n   * Our poor renderer is bound to his resolution forever :(\n   */\n\n  public resolution = {\n    x: 64,\n    y: 32,\n    scale: 8\n  };\n\n  /**\n   * giving up and resorting to any type\n   * seems to work now\n   * we'll assign our canvas to a local property\n   */\n\n  constructor(canvas: any) {\n    this.canvas = canvas.current;\n    this.boot();\n  }\n\n  public toggleGrid() {\n    this.grid = !this.grid;\n  }\n\n  /**\n   * Some basic canvas stuff here we're going to get a 2d canvas context\n   * we're going to give the canvas height and width dimension * scale\n   */\n\n  boot() {\n    this.context = this.canvas.getContext('2d');\n    this.canvas.width = this.resolution.x * this.resolution.scale;\n    this.canvas.height = this.resolution.y * this.resolution.scale;\n\n    this.disp_clear();\n  }\n\n  public disp_clear() {\n    /**\n     * man i cannot get typescript to shut the fuck about how this might be null\n     * look at all this extra code\n     * i love typescript but she doesnt make it easy\n     */\n    this.context?.clearRect &&\n      this.context.clearRect(\n        0,\n        0,\n        this.resolution.x * this.resolution.scale,\n        this.resolution.y * this.resolution.scale\n      );\n  }\n\n  public paint(screen: Uint8Array) {\n    /**\n     * Start every render by clearing the screen\n     */\n    this.disp_clear();\n\n    if (this.context) {\n      const context = this.context;\n      const resolution = this.resolution;\n\n      screen.map((pixel, position) => {\n        /**\n         * return the remainder of the position and multiply it by our scale to get our x/y position\n         */\n        const x = (position % resolution.x) * resolution.scale;\n        const y = Math.floor(position / resolution.x) * resolution.scale;\n\n        /**\n         * our pixel is either on or off (0 or 1) so here we present an array with two options\n         * off is 0 or background color\n         * on is 1 or foreground color\n         */\n\n        context.fillStyle = [this.colors.background, this.colors.foreground][\n          pixel\n        ];\n\n        context.strokeStyle = [this.colors.background, this.colors.foreground][\n          pixel\n        ];\n\n        /**\n         * at our x and y coordinate paint a a square matching our scale size and fill color\n         */\n\n        if (pixel || !this.grid) {\n          context.fillRect(x, y, this.resolution.scale, this.resolution.scale);\n        } else {\n          context.strokeRect(\n            x,\n            y,\n            this.resolution.scale,\n            this.resolution.scale\n          );\n        }\n        return pixel;\n      });\n    }\n  }\n}\n","/**\n *\n * CHIP-8 keyboard adapter\n * @author Darryl Walker\n *\n */\n\nimport Cpu from './cpu';\n\nexport default class Keyboard {\n  /**\n   * make a slot for our cpu\n   */\n\n  cpu;\n\n  /**\n   * we need to map keys from a modern keyboard to the 16-key one CHIP-8 suppors\n   */\n\n  constructor(cpu: Cpu) {\n    this.cpu = cpu;\n    this.listen();\n  }\n\n  public press(key: string) {\n    let input;\n\n    /**\n     * use switch to listen for the keys we care about\n     */\n\n    switch (key) {\n      /**\n       * pause / unpause when esc/spacebar is pressed\n       */\n      case ' ':\n      case 'Escape': {\n        if (this.cpu.running) {\n          this.cpu.stop();\n        } else {\n          this.cpu.start();\n        }\n        break;\n      }\n      /**\n       * below inputs are mapped to the hex pad\n       * we'll copy this guy because i cant think of a better way\n       * https://github.com/eshyong/Chip-8-Emulator\n       * |1|2|3|C|\t\t=>\t\t|1|2|3|4|\n       * |4|5|6|D|\t\t=>\t\t|Q|W|E|R|\n       * |7|8|9|E|\t\t=>\t\t|A|S|D|F|\n       * |A|0|B|F|\t\t=>\t\t|Z|X|C|V|\n       */\n      case '1': {\n        input = 0x0001;\n        break;\n      }\n      case '2': {\n        input = 0x0002;\n        break;\n      }\n      case '3': {\n        input = 0x0003;\n        break;\n      }\n      case '4': {\n        input = 0x000c;\n        break;\n      }\n      case 'q': {\n        input = 0x0004;\n        break;\n      }\n      case 'w': {\n        input = 0x0005;\n        break;\n      }\n      case 'e': {\n        input = 0x0006;\n        break;\n      }\n      case 'r': {\n        input = 0x000d;\n        break;\n      }\n      case 'a': {\n        input = 0x0007;\n        break;\n      }\n      case 's': {\n        input = 0x0008;\n        break;\n      }\n      case 'd': {\n        input = 0x0009;\n        break;\n      }\n      case 'f': {\n        input = 0x000e;\n        break;\n      }\n      case 'z': {\n        input = 0x000a;\n        break;\n      }\n      case 'x': {\n        input = 0x0000;\n        break;\n      }\n      case 'c': {\n        input = 0x000b;\n        break;\n      }\n      case 'v': {\n        input = 0x000f;\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n\n    /**\n     * pass the input to the cpu\n     */\n\n    if (input) {\n      this.cpu.input(input);\n    }\n  }\n\n  public release() {\n    this.cpu.input(0x00ff);\n  }\n\n  listen() {\n    if (this.cpu) {\n      document.addEventListener('keydown', event => {\n        const { key } = event;\n\n        this.press(key);\n      });\n\n      /**\n       * listen for keyup and clear the key register\n       * send it 255 if we're clear\n       */\n      document.addEventListener('keyup', () => {\n        this.release();\n      });\n    }\n  }\n}\n","/**\n *\n * CHIP.ts - A CHIP-8 emulator in TypeScript\n * @author Darryl Walker\n *\n */\n\nimport Cpu from './drivers/cpu';\nimport Gfx from './drivers/gfx';\nimport Keyboard from './drivers/keyboard';\n\nexport default class Chip {\n  /**\n   * Configure our preferred target framerate\n   * We'll also configure our frame pointer and play state\n   * Timing function from https://gist.github.com/addyosmani/5434533#gistcomment-2018050\n   */\n\n  speed = 100;\n  frame = 0;\n\n  /**\n   * stub our cpu and gfx so we can access them publicly\n   */\n\n  public cpu;\n  public gfx;\n  public keyboard;\n\n  /**\n   * i couldnt figure out how to make typescript happy with canvas so i've checked it can't be null up the chain - bit risky tho\n   *\n   * @param rom - a CHIP-8 rom file as a Uint8Array\n   * @param canvas - an html canvas element for our renderer\n   */\n\n  constructor(rom: Uint8Array, canvas: any) {\n    const gfx = new Gfx(canvas);\n    const cpu = new Cpu(rom, gfx);\n\n    this.cpu = cpu;\n    this.gfx = gfx;\n\n    this.keyboard = new Keyboard(cpu);\n\n    this.start(cpu, gfx);\n  }\n\n  /**\n   * start will kick off our timing function\n   * this is going to check 60 times per second\n   * requestAnimationFrame is a browser API that helps us\n   * with render timing\n   */\n\n  start(cpu: Cpu, gfx: Gfx) {\n    let working = false;\n\n    setInterval(() => {\n      if (working) {\n        return;\n      }\n\n      working = true;\n      cpu.next();\n      working = false;\n    }, 1000 / this.speed);\n\n    /**\n     * let's start a clock\n     */\n\n    const animateLoop = () => {\n      this.frame = requestAnimationFrame(animateLoop);\n\n      const screen = cpu.display;\n      gfx.paint(screen);\n    };\n\n    /**\n     * Once started the animateLoop function will call itself recursively\n     */\n\n    this.frame = requestAnimationFrame(animateLoop);\n  }\n\n  stop() {\n    cancelAnimationFrame(this.frame);\n  }\n}\n","import { useState, useEffect, useRef, useCallback } from 'react';\nimport { Field, Form, Formik } from 'formik';\nimport request from 'axios';\nimport isClient from '@bagofholding/is-client';\n\nimport Chip from '../../libs/chip/chip';\n\nimport './App.scss';\n\nfunction App() {\n  const canvas = useRef(null);\n\n  const games = ['Brix', 'Tetris', 'Pong'];\n  const keypad = [\n    ['1', '2', '3', '4'],\n    ['q', 'w', 'e', 'r'],\n    ['a', 's', 'd', 'f'],\n    ['z', 'x', 'c', 'v']\n  ];\n  const instructions: IInstructions = {\n    brix: 'Left: Q | Right: E',\n    tetris: 'Left: W | Right: E | Rotate: Q',\n    pong: 'P1 Up: 1 | P1 Down: Q | P2 Up: 4 | P2 Down: R'\n  };\n  const [slot, setSlot] = useState(games[0].toLowerCase());\n\n  const fetchData = useCallback(async () => {\n    /**\n     * sadly superagent does not support blobs in userland\n     * we have retired it here in favour of axios\n     */\n    const response = await request({\n      url: `${process.env.PUBLIC_URL}/roms/${slot}`,\n      method: 'GET',\n      responseType: 'blob'\n    });\n\n    const blob = new Blob([response.data]);\n    const buffer = await blob.arrayBuffer();\n    const rom = new Uint8Array(buffer);\n    const chip = new Chip(rom, canvas);\n\n    window.chip = chip;\n  }, [slot]);\n\n  useEffect(() => {\n    if (isClient() && canvas && canvas?.current) {\n      fetchData();\n    }\n  }, [slot, canvas, fetchData]);\n\n  const handleButtonPress = (key: string) => {\n    if (isClient()) {\n      window.chip.keyboard.press(key);\n\n      /**\n       * we then wait a little time to fake a real keypress\n       * the key needs to be released manually\n       */\n\n      setTimeout(() => {\n        window.chip.keyboard.release();\n      }, 200);\n    }\n  };\n\n  const handleToggleGrid = () => {\n    if (isClient()) {\n      window.chip.gfx.toggleGrid();\n    }\n  };\n\n  return (\n    <div className=\"container app\">\n      <div className=\"row\">\n        <div className=\"col-12 text-center mb-3\">\n          <h1 className=\"mb-0\">CHIP.ts</h1>\n          <h2>\n            <small className=\"text-muted\">\n              A CHIP-8 emulator in TypeScript\n            </small>\n          </h2>\n          <canvas data-testid=\"canvas\" ref={canvas} />\n        </div>\n      </div>\n\n      <div className=\"row\">\n        <div className=\"col-6 text-center mb-2\">\n          <button\n            className=\"btn btn-secondary\"\n            onClick={() => {\n              handleButtonPress('Escape');\n            }}\n          >\n            Pause (Escape / Spacebar)\n          </button>\n        </div>\n        <div className=\"col-6 text-center mb-2\">\n          <button\n            className=\"btn btn-secondary\"\n            onClick={() => {\n              handleToggleGrid();\n            }}\n          >\n            Toggle Grid\n          </button>\n        </div>\n        <div className=\"col-12\">\n          {/** virtual keypad */}\n          {keypad.map((row, i) => (\n            <div key={i} className=\"row\">\n              {row.map((column: string) => (\n                <div key={column} className=\"col-3 text-center mb-2\">\n                  <button\n                    className=\"btn btn-secondary w-100\"\n                    onClick={() => {\n                      handleButtonPress(column);\n                    }}\n                  >\n                    {column.toUpperCase()}\n                  </button>\n                </div>\n              ))}\n            </div>\n          ))}\n        </div>\n      </div>\n\n      {instructions[slot] && (\n        <div className=\"row\">\n          <div className=\"col-12\">\n            <div className=\"alert alert-secondary\" role=\"alert\">\n              <h2>{slot} keys:</h2>\n              {instructions[slot.toLowerCase()]}\n            </div>\n          </div>\n        </div>\n      )}\n      <Formik\n        initialValues={{ slot }}\n        onSubmit={values => {\n          setSlot(values.slot);\n        }}\n      >\n        <Form className=\"row justify-content-lg-center\">\n          <div className=\"col-12 text-center\">\n            <h3>Choose a game</h3>\n            <Field as=\"select\" className=\"form-control\" name=\"slot\">\n              {games.map(game => (\n                <option key={game} value={game.toLowerCase()}>\n                  {game}\n                </option>\n              ))}\n            </Field>\n            <hr />\n            <button className=\"btn btn-primary\" type=\"submit\">\n              Load\n            </button>\n            <hr />\n            <a\n              className=\"btn btn-light\"\n              href=\"https://github.com/PenguinOfWar/chip.ts\"\n            >\n              View code on GitHub\n            </a>\n          </div>\n        </Form>\n      </Formik>\n    </div>\n  );\n}\n\nexport interface IInstructions {\n  [key: string]: string;\n}\n\ndeclare global {\n  interface Window {\n    chip: Chip;\n  }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './containers/App/App';\n\nimport reportWebVitals from './reportWebVitals';\n\nimport './sass/index.scss';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}