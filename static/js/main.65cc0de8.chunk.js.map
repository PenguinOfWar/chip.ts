{"version":3,"sources":["libs/chip/assets/characters.ts","libs/chip/drivers/cpu.ts","libs/chip/drivers/gfx.ts","libs/chip/drivers/keyboard.ts","libs/chip/chip.ts","containers/App/App.tsx","reportWebVitals.ts","index.tsx"],"names":["fonts","AudioContext","window","webkitAudioContext","Cpu","rom","gfx","memory","Uint8Array","ArrayBuffer","registers","stack","Uint16Array","stackPointer","counter","pointer","screen","delayTimer","soundTimer","keys","key","speaker","wave","running","this","resolution","x","y","load","loadFont","map","instruction","address","addressMap","start","char","index","tick","beep","opcode","NN","JUMP","didJump","disp_clear","console","warn","Error","toString","Math","floor","random","spr","height","coordinates","vertical","horizontal","scale","setPixel","stop","pointers","i","width","location","display","oscillator","createOscillator","connect","destination","type","setTimeout","close","Gfx","canvas","colors","background","foreground","context","grid","current","boot","getContext","pixel","position","fillStyle","strokeStyle","fillRect","strokeRect","Keyboard","cpu","listen","input","document","addEventListener","event","press","release","games","keypad","instructions","brix","tetris","pong","ufo","ibm","invaders","missile","tank","maze","Chip","game","speed","frame","keyboard","specialCases","toLowerCase","working","setInterval","next","requestAnimationFrame","animateLoop","paint","cancelAnimationFrame","halt","App","useRef","useState","slot","setSlot","fetchData","useCallback","a","chip","request","url","process","method","responseType","response","blob","Blob","data","arrayBuffer","buffer","useEffect","isClient","handleButtonPress","className","data-testid","ref","onClick","toggleGrid","row","column","toUpperCase","role","initialValues","onSubmit","values","as","name","value","href","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.65cc0de8.chunk.js","sourcesContent":["export const fonts = [\n  0xf0,\n  0x90,\n  0x90,\n  0x90,\n  0xf0, // 0\n  0x20,\n  0x60,\n  0x20,\n  0x20,\n  0x70, // 1\n  0xf0,\n  0x10,\n  0xf0,\n  0x80,\n  0xf0, // 2\n  0xf0,\n  0x10,\n  0xf0,\n  0x10,\n  0xf0, // 3\n  0x90,\n  0x90,\n  0xf0,\n  0x10,\n  0x10, // 4\n  0xf0,\n  0x80,\n  0xf0,\n  0x10,\n  0xf0, // 5\n  0xf0,\n  0x80,\n  0xf0,\n  0x90,\n  0xf0, // 6\n  0xf0,\n  0x10,\n  0x20,\n  0x40,\n  0x40, // 7\n  0xf0,\n  0x90,\n  0xf0,\n  0x90,\n  0xf0, // 8\n  0xf0,\n  0x90,\n  0xf0,\n  0x10,\n  0xf0, // 9\n  0xf0,\n  0x90,\n  0xf0,\n  0x90,\n  0x90, // A\n  0xe0,\n  0x90,\n  0xe0,\n  0x90,\n  0xe0, // B\n  0xf0,\n  0x80,\n  0x80,\n  0x80,\n  0xf0, // C\n  0xe0,\n  0x90,\n  0x90,\n  0x90,\n  0xe0, // D\n  0xf0,\n  0x80,\n  0xf0,\n  0x80,\n  0xf0, // E\n  0xf0,\n  0x80,\n  0xf0,\n  0x80,\n  0x80 // F\n];\n","/**\n *\n * CHIP-8 CPU emulator class\n * @author Darryl Walker\n *\n */\n\nimport Gfx from './gfx';\nimport { fonts } from '../assets/characters';\n\nconst AudioContext = window.AudioContext || window.webkitAudioContext;\n\nexport default class Cpu {\n  /**\n   * CHIP-8 has 4096 8-bit (1 byte) memory locations\n   * A byte is normally the smallest addressable location\n   * Each byte can be a value of 0-255\n   *\n   * Our 4096 decimal can expressed as 0x1000 in hexadecimal\n   * We will create a new ArrayBuffer and pass it to Uint8Array (unsigned integer with a range of 0-255)\n   * Array buffer will handle our raw data for us e.g. 0x1000 => 4096\n   */\n\n  memory = new Uint8Array(new ArrayBuffer(0x1000));\n\n  /**\n   * CHIP-8 has 16 8-bit data registers named V0 to VF\n   * We create a new Uint8Array with 16 register locations\n   */\n\n  registers = new Uint8Array(16);\n\n  /**\n   * Our stack will need to store return addresses\n   * We will need 16 of these 16-bit addresses\n   */\n\n  stack = new Uint16Array(16);\n\n  /**\n   * Our stack pointer will store where in our 16 length stack we should be\n   */\n\n  stackPointer = 0;\n\n  /**\n   * We need to define our program counter\n   * This is the next instruction that should be executed by our cpu\n   * CHIP-8 starts at 0x200 leaving the lowest 512 bytes (0-511) free\n   * We'll store font data there later\n   */\n\n  counter = 0x200;\n\n  /**\n   * Assign a position for our graphics adapter\n   */\n\n  gfx;\n\n  /**\n   * okay so this is a pointer i've called pointer\n   * in reality it's confusingly called \"I\"\n   * i like mine better for now\n   * on the CHIP-8 it's a 16-bit register so a regular number is fine\n   */\n\n  pointer = 0;\n\n  /**\n   * Our screen space will be an array representing pixels\n   * left to right, top to bottom, 8-bits (1-byte) each\n   */\n\n  public screen = new Uint8Array();\n\n  /**\n   * we have two timers- one for delay and one for sound\n   */\n\n  delayTimer = 0;\n  soundTimer = 0;\n\n  /**\n   * Keypad - used as input from a HEX keypad\n   */\n\n  keys: IKeys = {};\n\n  /**\n   * at any given time we can have one key pressed\n   * so we'll keep track of it via a pointer\n   */\n\n  key = 0;\n\n  /**\n   * we will also need a virtual keyboard and sound adapter\n   */\n\n  speaker = new AudioContext();\n  wave: OscillatorType = 'sawtooth';\n\n  /**\n   * We need a way to track whether or not ops should be paused\n   * a boolean will do\n   */\n\n  public running = false;\n\n  constructor(rom: Uint8Array, gfx: Gfx) {\n    this.gfx = gfx;\n    this.screen = new Uint8Array(this.gfx.resolution.x * this.gfx.resolution.y);\n    this.load(rom);\n  }\n\n  /**\n   * We take the ROM file represented as a Uint8Array and map into memory\n   * Here we need to ecounter for the original interpreter positions\n   * For this reason, most programs written for the original system begin at memory location 512 (0x200)\n   * We shift all the memory addresses over by 512 (or 0x200 for fun)\n   */\n\n  load(rom: Uint8Array) {\n    /**\n     * load fonts first\n     */\n\n    this.loadFont();\n\n    rom.map((instruction, address) => {\n      /**\n       * take the instrction and the array index as our memory address\n       * map this into our emulators memory\n       */\n\n      const addressMap = address + 0x200;\n\n      this.memory[addressMap] = instruction;\n\n      return instruction;\n    });\n\n    /**\n     * it's always useful if you remember to start the engine\n     */\n    this.start();\n  }\n\n  /**\n   * We need to load a hexadecimal character set into the first few bytes of our memory\n   * we have 512 free slots to play with in total\n   */\n  loadFont() {\n    return fonts.map((char, index) => {\n      return (this.memory[index] = char);\n    });\n  }\n\n  public start() {\n    this.running = true;\n  }\n\n  public stop() {\n    this.running = false;\n  }\n\n  /**\n   * We will provided a handle little API for the chip to call for a tick at the preferred rate\n   * next will check if the cpu is running and tick if true\n   */\n\n  public next() {\n    if (!this.running) {\n      return;\n    }\n\n    this.tick();\n  }\n\n  /**\n   * Our processor will perform an instruction once per tick\n   * During this time we will check the opcode and see what it needs to do\n   */\n\n  tick() {\n    /**\n     * before we do anything we have to decrement our timers\n     */\n\n    if (this.delayTimer > 0) {\n      --this.delayTimer;\n    }\n\n    if (this.soundTimer > 0) {\n      /**\n       * if the sound timer is exactly 1 fire a beep off\n       */\n      if (this.running && this.soundTimer === 1) {\n        this.beep();\n      }\n\n      --this.soundTimer;\n    }\n\n    /**\n     * This bit is a little confusing to me\n     * I learned a lot of it from reading\n     * https://github.com/alexanderdickson/Chip-8-Emulator/blob/5da6ac6a4753462d02ca7fe8d5a9398308b8d9d0/scripts/chip8.js#L193\n     * We're shifting everything over bitwise 8 to the left\n     * And then doing a bitwise or on each pair of bits. a OR b yields 1 if either a or b is 1.\n     *\n     * UPDATE\n     * Bless this dude, who seems to be the reference for the above JS dude/dudette\n     * https://github.com/eshyong/Chip-8-Emulator/blob/master/chip8.c\n     *\n     * Opcodes are two bytes long!\n     * We're creating a hexidecimal here, I guess? Out of the two byte opcode\n     *\n     * here we take the first complete bite\n     * in pongs case that's 6A hex / 106 decimal√é\n     * we also take the next byte which is conveniently 02 hex / 2 decimal\n     *\n     * fuck me\n     * i guess this is a clever way of storing integers greater than 8 bits\n     * which is cool as shit\n     *\n     * we take decimal 106 and we shift it left 8 places giving us decimal 27136\n     *\n     * then we take output of that left shift and give it to a bitwise OR - the single pipe dude\n     * this guy adds them together\n     * problem: 27136 | 2\n     * result: 27138 decimal / 6a02 hex\n     *\n     * i guess we just got two bytes of storage out of one byte of data\n     * how very... bitwise\n     *\n     */\n\n    const opcode =\n      (this.memory[this.counter] << 8) | this.memory[this.counter + 1];\n\n    /**\n     * here a bitwise AND (&) compares two numbers and casts them to numbers if they arent numbers\n     * my head hurts\n     *\n     * Read here:\n     * https://en.wikipedia.org/wiki/Bitwise_operation#AND\n     *\n     * Okay.\n     * There's a lot going on here.\n     * X is a two parter, first we take our opcode 27136 and give it 0x0f00 hex / 3840 decimal\n     * this yields a00 hex / 2560 decimal\n     *\n     * we then shift the result over 8 places right yielding a hex / 10 decimal\n     * giving us our register address for later!\n     *\n     * do similar for y taking 27136 and giving it 0x0000 hex / 0 decimal and go god i keep flopping back and forth\n     * it's all hex i swear just different hex and i will tidy it up just look at the decimals\n     *\n     * shift it over 4 and it's still 0 / 0x0000\n     *\n     */\n\n    const x = (opcode & 0x0f00) >> 8;\n    const y = (opcode & 0x00f0) >> 4;\n    const NN = opcode & 0x00ff;\n    const JUMP = opcode & 0x0fff;\n    let didJump = false;\n\n    /**\n     * then start checking opcodes\n     *\n     * our first check is the result of opcode AND 0xf000\n     * continuing with the above we have 27138 & 61440 = 24576 decimal / 0x6000 hex\n     *\n     * this corresponds to opcode 6XNN!\n     * https://en.wikipedia.org/wiki/CHIP-8#Opcode_table\n     *\n     * this is called checking the first nibble of the byte\n     */\n\n    switch (opcode & 0xf000) {\n      /**\n       * 0000\n       * This can be a few things but we only really care about two of them - 00E0 and 00EE\n       */\n      case 0x0000: {\n        switch (opcode) {\n          /**\n           * 00E0 / disp_clear() - clears the screen\n           */\n          case 0x00e0:\n            this.disp_clear();\n            break;\n\n          /**\n           * 00EE / return from a subroutine\n           */\n          case 0x00ee:\n            if (this.stack[this.stackPointer] === 0) {\n              console.warn('Invalid return from subroutine.');\n            }\n\n            this.counter = this.stack[this.stackPointer];\n            this.stack[this.stackPointer] = 0;\n\n            if (this.stackPointer > 0) {\n              --this.stackPointer;\n            }\n            break;\n        }\n        break;\n      }\n\n      /**\n       * 1NNN - Jumps to address NNN.\n       */\n      case 0x1000: {\n        this.counter = JUMP;\n        didJump = true;\n        break;\n      }\n\n      /**\n       * 2NNN - Calls subroutine at NNN.\n       * Updates the counter to the next instruction\n       * We store the return address for later and increment our stack size\n       */\n      case 0x2000: {\n        if (this.stack[this.stackPointer] !== 0) {\n          ++this.stackPointer;\n        }\n        this.stack[this.stackPointer] = this.counter;\n        this.counter = JUMP;\n        didJump = true;\n        break;\n      }\n\n      /**\n       * 3XNN/if(Vx==NN) - Skips the next instruction if VX equals NN. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x3000: {\n        if (this.registers[x] === NN) {\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * 4XNN/if(Vx!=NN - Skips the next instruction if VX doesn't equal NN. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x4000: {\n        if (this.registers[x] !== NN) {\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * 5XY0/if(Vx==Vy) - Skips the next instruction if VX equals VY. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x5000: {\n        if (this.registers[x] === this.registers[y]) {\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * 6XNN - Sets VX to NN\n       * opcode AND 0xFF hex / 255 dec = 2 dec / 02 hex\n       * therefore register 10 now has a value of two\n       */\n      case 0x6000: {\n        this.registers[x] = opcode & 0xff;\n        break;\n      }\n\n      /**\n       * 7XNN - Adds NN to VX. (Carry flag is not changed)\n       */\n      case 0x7000: {\n        this.registers[x] += NN;\n        break;\n      }\n\n      /**\n       * 8000 is an imposing list of VX and VY operations\n       */\n\n      case 0x8000: {\n        switch (opcode & 0x000f) {\n          /**\n           * 8XY0/Vx=Vy - Sets VX to the value of VY.\n           */\n          case 0x0000: {\n            this.registers[x] = this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY1/Vx=Vx|Vy - Sets VX to VX or VY. (Bitwise OR operation)\n           */\n          case 0x0001: {\n            this.registers[x] = this.registers[x] | this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY2/Vx=Vx&Vy - Sets VX to VX and VY. (Bitwise AND operation)\n           */\n          case 0x0002: {\n            this.registers[x] = this.registers[x] & this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY3/Vx=Vx^Vy - Sets VX to VX xor VY.\n           */\n          case 0x0003: {\n            this.registers[x] = this.registers[x] ^ this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY4/Vx += Vy - Adds VY to VX. VF is set to 1 when there's a carry, and to 0 when there isn't.\n           */\n          case 0x0004: {\n            if (this.registers[x] + this.registers[y] > 255) {\n              this.registers[0xf] = 1;\n            } else {\n              this.registers[0xf] = 0;\n            }\n            this.registers[x] += this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY5/Vx -= Vy - VY is subtracted from VX. VF is set to 0 when there's a borrow, and 1 when there isn't.\n           */\n          case 0x0005: {\n            if (this.registers[x] < this.registers[y]) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] -= this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY6/Vx>>=1 - Stores the least significant bit of VX in VF and then shifts VX to the right by 1.\n           */\n          case 0x0006: {\n            if (this.registers[x] % 2 === 0) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] = this.registers[x] >> 1;\n            break;\n          }\n\n          /**\n           * 8XY7/Vx=Vy-Vx - Sets VX to VY minus VX. VF is set to 0 when there's a borrow, and 1 when there isn't.\n           */\n          case 0x0007: {\n            if (this.registers[y] < this.registers[x]) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] = this.registers[y] - this.registers[x];\n            break;\n          }\n\n          /**\n           * 8XYE/Vx<<=1 - Stores the most significant bit of VX in VF and then shifts VX to the left by 1\n           */\n          case 0x000e: {\n            if (this.registers[x] < 128) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] = this.registers[x] << 1;\n            break;\n          }\n          default: {\n            throw new Error(\n              `Unknown opcode in 8000 block: ${opcode.toString(16)}`\n            );\n          }\n        }\n        break;\n      }\n\n      /**\n       * we (i) forgot about instruction 9\n       * 9XY0/if(Vx!=Vy) - Skips the next instruction if VX doesn't equal VY. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x9000: {\n        // skip next instruction if VX not equals VY\n        if (this.registers[x] !== this.registers[y]) {\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * ANNN - Sets pointer/I to address NNN\n       */\n      case 0xa000: {\n        this.pointer = JUMP;\n        break;\n      }\n\n      /**\n       * BNNN - Jumps to addres that is sum of NNN and V0 (register 0)\n       */\n      case 0xb000: {\n        this.counter = (opcode & 0xfff) + this.registers[0];\n        didJump = true;\n        break;\n      }\n\n      /**\n       * CXNN/Vx=rand()&N - Sets VX to the result of a bitwise and operation on a random number (Typically: 0 to 255) and NN.\n       */\n      case 0xc000: {\n        this.registers[x] = Math.floor(Math.random() * 255) % 255 & NN;\n        break;\n      }\n\n      /**\n       * DXYN / draw(Vx,Vy,N) - Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N+1 pixels.\n       */\n      case 0xd000: {\n        const height = opcode & 0x000f;\n\n        /**\n         * get our x and y coordinates from our register\n         * use values at position VX and VY\n         */\n\n        let coordinates: ICoordinates = {\n          x: this.registers[x],\n          y: this.registers[y]\n        };\n\n        // set carry flag to 0\n        this.registers[0xf] = 0;\n\n        let spr;\n\n        /**\n         * drawing loop\n         * try not to get it backwards like i did\n         */\n        for (let vertical = 0; vertical < height; vertical++) {\n          spr = this.memory[this.pointer + vertical];\n\n          for (\n            let horizontal = 0;\n            horizontal < this.gfx.resolution.scale;\n            horizontal++\n          ) {\n            if (coordinates.x + horizontal === this.gfx.resolution.x) {\n              coordinates.x = -horizontal;\n            }\n            if (coordinates.y + vertical === this.gfx.resolution.y) {\n              coordinates.y = -vertical;\n            }\n\n            if ((spr & 0x80) > 0) {\n              if (\n                this.setPixel(\n                  this.registers[x] + horizontal,\n                  this.registers[y] + vertical\n                )\n              ) {\n                this.registers[0xf] = 1;\n              }\n            }\n            spr <<= 1;\n          }\n          coordinates.x = this.registers[x];\n          coordinates.y = this.registers[y];\n        }\n\n        break;\n      }\n\n      /**\n       * E000 can be one of two things, both bound to key presses\n       * they are kind of the opposite of one another\n       */\n      case 0xe000: {\n        switch (NN) {\n          /**\n           * EX9E/if(key()==Vx) - Skips the next instruction if the key stored in VX is pressed. (Usually the next instruction is a jump to skip a code block)\n           */\n          case 0x009e: {\n            if (this.key === this.registers[x]) {\n              this.counter += 2;\n            }\n            break;\n          }\n\n          /**\n           * EXA1/if(key()!=Vx) - Skips the next instruction if the key stored in VX isn't pressed. (Usually the next instruction is a jump to skip a code block)\n           */\n          case 0x00a1: {\n            if (this.key !== this.registers[x]) {\n              this.counter += 2;\n            }\n            break;\n          }\n          default: {\n            throw new Error(\n              `Unknown opcode in e000 block: ${opcode.toString(16)}`\n            );\n          }\n        }\n        break;\n      }\n\n      /**\n       * ol mate F000 can be a few things\n       */\n      case 0xf000: {\n        switch (NN) {\n          /**\n           * FX07/get_delay() -\tSets VX to the value of the delay timer.\n           */\n          case 0x0007: {\n            this.registers[x] = this.delayTimer;\n            break;\n          }\n          /**\n           * FX0A/get_key() - A key press is awaited, and then stored in VX. (Blocking Operation. All instruction halted until next key event)\n           * What this means is we are actually going to halt the program and wait until a key is pressed\n           */\n          case 0x000a: {\n            if (this.key === 0) {\n              this.stop();\n              return;\n            } else {\n              /**\n               * before we start again should we clear the screen ram and pause the rendering there too?\n               */\n              this.registers[x] = this.key;\n              this.start();\n              break;\n            }\n          }\n\n          /**\n           * FX15/delay_timer(Vx) - Sets the delay timer to VX.\n           */\n          case 0x0015: {\n            this.delayTimer = this.registers[x];\n            break;\n          }\n\n          /**\n           * FX18/sound_timer(Vx) - Sets the sound timer to VX.\n           */\n          case 0x0018: {\n            this.soundTimer = this.registers[x];\n            break;\n          }\n\n          /**\n           * X1E - Adds VX to pointer/I. VF is not affected\n           */\n          case 0x001e: {\n            this.pointer += this.registers[x];\n            break;\n          }\n\n          /**\n           * FX29 - I=sprite_addr[Vx] - Sets I to the location of the sprite for the character in VX.\n           * Characters 0-F (in hexadecimal) are represented by a 4x5 font.\n           * we multiply by 5 to get there\n           */\n          case 0x0029: {\n            this.pointer = this.registers[x] * 5;\n            break;\n          }\n\n          /**\n           * FX33/set_BCD - Stores the binary-coded decimal representation of VX, with the most significant of\n           * three digits at the address in I, the middle digit at I plus 1, and the least significant digit at\n           * I plus 2. (In other words, take the decimal representation of VX, place the hundreds digit in memory\n           * at location in I, the tens digit at location I+1, and the ones digit at location I+2.)\n           */\n          case 0x0033: {\n            const pointers = [\n              this.registers[x] / 100,\n              (this.registers[x] / 10) % 10,\n              this.registers[x] % 10\n            ];\n            this.memory[this.pointer] = pointers[0];\n            this.memory[this.pointer + 1] = pointers[1];\n            this.memory[this.pointer + 2] = pointers[2];\n            break;\n          }\n\n          /**\n           * FX55/reg_dump(Vx,&I) - Stores V0 to VX (including VX) in memory starting at address I.\n           */\n          case 0x0055: {\n            for (let i = 0; i <= x; i++) {\n              this.memory[this.pointer + i] = this.registers[i];\n            }\n            break;\n          }\n\n          /**\n           * FX65/reg_load(Vx,&I) - Fills V0 to VX (including VX) with values from memory starting at address I.\n           */\n          case 0x0065: {\n            for (let i = 0; i <= x; i++) {\n              this.registers[i] = this.memory[this.pointer + i];\n            }\n            this.pointer = this.pointer + x + 1;\n            break;\n          }\n        }\n        break;\n      }\n      default: {\n        throw new Error(`Unknown opcode: ${opcode.toString(16)}`);\n      }\n    }\n\n    /**\n     * all of our instructions are two bytes long\n     * increment our counter+2 to move to the next instruction by default\n     */\n\n    if (!didJump) {\n      this.counter += 2;\n    }\n  }\n\n  get display() {\n    return this.screen;\n  }\n\n  /**\n   * do our set pixel handling here\n   */\n  setPixel(x: number, y: number) {\n    const width = this.gfx.resolution.x;\n    const height = this.gfx.resolution.y;\n\n    // If the pixel exceeds the dimensions,\n    // wrap it back around.\n    if (x > width) {\n      x -= width;\n    } else if (x < 0) {\n      x += width;\n    }\n\n    if (y > height) {\n      y -= height;\n    } else if (y < 0) {\n      y += height;\n    }\n\n    const location = x + y * width;\n\n    this.display[location] ^= 1;\n\n    return !this.screen[location];\n  }\n\n  /**\n   * provide a public api for the keyboard drive to update the key pressed\n   */\n  public input(key: any) {\n    this.key = key;\n  }\n\n  /**\n   * CHIP-8 has a single voice speaker to beep at you\n   * we'll make a beep method for our cpu (or anyone) to use\n   */\n  public beep() {\n    if (this.speaker) {\n      const oscillator = this.speaker.createOscillator();\n      oscillator.connect(this.speaker.destination);\n      /**\n       * i think sawtooth sounds the most retro and its my code so we're sticking with it\n       * there also seems to be an issue here with the oscillator context hanging around\n       * cant quite figure out how to close it gracefully\n       */\n      oscillator.type = this.wave;\n      oscillator.start();\n      setTimeout(() => {\n        oscillator.stop();\n      }, 100);\n      return;\n    }\n  }\n\n  /**\n   * We need to add a halt procedure here primarily to close the audiocontext\n   * it gets really annoying otherwise as sound loops can get stuck in the browser window\n   * dont ask me how i know this\n   */\n\n  public halt() {\n    if (this.speaker) {\n      this.speaker.close();\n    }\n  }\n\n  /**\n   * clear the display\n   */\n  public disp_clear() {\n    /**\n     * feed our paint method an empty screen array and force a new paint\n     */\n\n    const screen = new Uint8Array(\n      this.gfx.resolution.x * this.gfx.resolution.y\n    );\n    this.screen = screen;\n  }\n}\n\nexport interface ICoordinates {\n  x: number;\n  y: number;\n}\n\nexport interface IKeys {\n  [key: number]: any;\n}\n","/**\n *\n * CHIP.ts canvas render methods\n * @author Darryl Walker\n *\n */\n\nexport default class Gfx {\n  /**\n   * we get 2 whole colours to play with here\n   * our background will be black and our foreground classic monochrome green\n   */\n\n  colors = {\n    background: '#000',\n    foreground: '#00ff00'\n  };\n\n  /**\n   * This class will receive input from a buffer and draw a new screen\n   * Canvas is convenient and cool so we'll use that\n   */\n\n  canvas: any = null;\n  context: CanvasRenderingContext2D | null = null;\n  grid = false;\n\n  /**\n   * Here we configure graphics information\n   * CHIP-8 has a display resolution of 64x32 and we'll scale it up 8 times\n   * Our poor renderer is bound to his resolution forever :(\n   */\n\n  public resolution = {\n    x: 64,\n    y: 32,\n    scale: 8\n  };\n\n  /**\n   * giving up and resorting to any type\n   * seems to work now\n   * we'll assign our canvas to a local property\n   */\n\n  constructor(canvas: any) {\n    this.canvas = canvas.current;\n    this.boot();\n  }\n\n  public toggleGrid() {\n    this.grid = !this.grid;\n  }\n\n  /**\n   * Some basic canvas stuff here we're going to get a 2d canvas context\n   * we're going to give the canvas height and width dimension * scale\n   */\n\n  boot() {\n    this.context = this.canvas.getContext('2d');\n    this.canvas.width = this.resolution.x * this.resolution.scale;\n    this.canvas.height = this.resolution.y * this.resolution.scale;\n  }\n\n  public paint(screen: Uint8Array) {\n    if (this.context) {\n      const context = this.context;\n      const resolution = this.resolution;\n\n      screen.map((pixel, position) => {\n        /**\n         * return the remainder of the position and multiply it by our scale to get our x/y position\n         */\n        const x = (position % resolution.x) * resolution.scale;\n        const y = Math.floor(position / resolution.x) * resolution.scale;\n\n        /**\n         * our pixel is either on or off (0 or 1) so here we present an array with two options\n         * off is 0 or background color\n         * on is 1 or foreground color\n         */\n\n        context.fillStyle = [this.colors.background, this.colors.foreground][\n          pixel\n        ];\n\n        context.strokeStyle = [this.colors.background, this.colors.foreground][\n          pixel\n        ];\n\n        /**\n         * at our x and y coordinate paint a a square matching our scale size and fill color\n         */\n\n        if (pixel || !this.grid) {\n          context.fillRect(x, y, this.resolution.scale, this.resolution.scale);\n        } else {\n          context.strokeRect(\n            x,\n            y,\n            this.resolution.scale,\n            this.resolution.scale\n          );\n        }\n        return pixel;\n      });\n    }\n  }\n}\n","/**\n *\n * CHIP-8 keyboard adapter\n * @author Darryl Walker\n *\n */\n\nimport Cpu from './cpu';\n\nexport default class Keyboard {\n  /**\n   * make a slot for our cpu\n   */\n\n  cpu;\n\n  /**\n   * we need to map keys from a modern keyboard to the 16-key one CHIP-8 suppors\n   */\n\n  constructor(cpu: Cpu) {\n    this.cpu = cpu;\n    this.listen();\n  }\n\n  public press(key: string) {\n    let input;\n\n    /**\n     * use switch to listen for the keys we care about\n     */\n\n    switch (key) {\n      /**\n       * pause / unpause when esc/spacebar is pressed\n       */\n      case ' ':\n      case 'Escape': {\n        if (this.cpu.running) {\n          this.cpu.stop();\n        } else {\n          this.cpu.start();\n        }\n        break;\n      }\n      /**\n       * below inputs are mapped to the hex pad\n       * we'll copy this guy because i cant think of a better way\n       * https://github.com/eshyong/Chip-8-Emulator\n       * |1|2|3|C|\t\t=>\t\t|1|2|3|4|\n       * |4|5|6|D|\t\t=>\t\t|Q|W|E|R|\n       * |7|8|9|E|\t\t=>\t\t|A|S|D|F|\n       * |A|0|B|F|\t\t=>\t\t|Z|X|C|V|\n       */\n      case '1': {\n        input = 0x0001;\n        break;\n      }\n      case '2': {\n        input = 0x0002;\n        break;\n      }\n      case '3': {\n        input = 0x0003;\n        break;\n      }\n      case '4': {\n        input = 0x000c;\n        break;\n      }\n      case 'q': {\n        input = 0x0004;\n        break;\n      }\n      case 'w': {\n        input = 0x0005;\n        break;\n      }\n      case 'e': {\n        input = 0x0006;\n        break;\n      }\n      case 'r': {\n        input = 0x000d;\n        break;\n      }\n      case 'a': {\n        input = 0x0007;\n        break;\n      }\n      case 's': {\n        input = 0x0008;\n        break;\n      }\n      case 'd': {\n        input = 0x0009;\n        break;\n      }\n      case 'f': {\n        input = 0x000e;\n        break;\n      }\n      case 'z': {\n        input = 0x000a;\n        break;\n      }\n      case 'x': {\n        input = 0x0000;\n        break;\n      }\n      case 'c': {\n        input = 0x000b;\n        break;\n      }\n      case 'v': {\n        input = 0x000f;\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n\n    /**\n     * pass the input to the cpu\n     */\n\n    if (input) {\n      this.cpu.input(input);\n    }\n  }\n\n  public release() {\n    this.cpu.input(0);\n  }\n\n  listen() {\n    if (this.cpu) {\n      document.addEventListener('keydown', event => {\n        const { key } = event;\n\n        this.press(key);\n      });\n\n      /**\n       * listen for keyup and clear the key register\n       * send it 0 if we're clear because why on earth should it be anything but\n       * note to self: when consulting the ancient texts they are not 1-2-1 gospel. ta.\n       */\n      document.addEventListener('keyup', () => {\n        this.release();\n      });\n    }\n  }\n}\n","/**\n *\n * CHIP.ts - A CHIP-8 emulator in TypeScript\n * @author Darryl Walker\n *\n */\n\nimport Cpu from './drivers/cpu';\nimport Gfx from './drivers/gfx';\nimport Keyboard from './drivers/keyboard';\n\n/**\n * export some common stuff\n */\n\nexport const games = [\n  'Invaders',\n  'Brix',\n  'Tetris',\n  'Pong',\n  'UFO',\n  'IBM',\n  'Missile',\n  'Tank',\n  'Maze'\n];\n\nexport const keypad = [\n  ['1', '2', '3', '4'],\n  ['q', 'w', 'e', 'r'],\n  ['a', 's', 'd', 'f'],\n  ['z', 'x', 'c', 'v']\n];\n\nexport const instructions: IInstructions = {\n  brix: 'Left: Q | Right: E',\n  tetris: 'Left: W | Right: E | Rotate: Q',\n  pong: 'P1 Up: 1 | P1 Down: Q | P2 Up: 4 | P2 Down: R',\n  ufo: 'Up/Left: Q | Up: W | Up/Right: E',\n  ibm: 'None',\n  invaders: 'Start: W | Shoot: W| Left: Q | Right: R',\n  missile: 'Shoot: S',\n  tank: 'Shoot: W | Left: Q | Up: S | Right: E | Down: 2',\n  maze: 'None'\n};\n\nexport interface SpecialCases {\n  [key: string]: any;\n}\n\nexport interface IInstructions {\n  [key: string]: string;\n}\n\nexport default class Chip {\n  /**\n   * Configure our preferred target framerate\n   * We'll also configure our frame pointer and play state\n   * Timing function from https://gist.github.com/addyosmani/5434533#gistcomment-2018050\n   */\n\n  speed = 120;\n  frame = 0;\n\n  /**\n   * stub our cpu and gfx so we can access them publicly\n   */\n\n  public cpu;\n  public gfx;\n  public keyboard;\n\n  /**\n   * lets fine tune some specific games\n   * our maximum is 1000\n   */\n\n  specialCases: SpecialCases = {};\n\n  /**\n   * i couldnt figure out how to make typescript happy with canvas so i've checked it can't be null up the chain - bit risky tho\n   *\n   * @param rom - a CHIP-8 rom file as a Uint8Array\n   * @param canvas - an html canvas element for our renderer\n   */\n\n  constructor(game: string, rom: Uint8Array, canvas: any) {\n    /**\n     * before we do anything check for special cases\n     */\n\n    if (this.specialCases[game.toLowerCase()]) {\n      this.speed = this.specialCases[game.toLowerCase()].speed || this.speed;\n    }\n\n    const gfx = new Gfx(canvas);\n    const cpu = new Cpu(rom, gfx);\n\n    this.cpu = cpu;\n    this.gfx = gfx;\n\n    this.keyboard = new Keyboard(cpu);\n\n    this.start(cpu, gfx);\n  }\n\n  /**\n   * start will kick off our timing function\n   * this is going to check 60 times per second\n   * requestAnimationFrame is a browser API that helps us\n   * with render timing\n   */\n\n  start(cpu: Cpu, gfx: Gfx) {\n    let working = false;\n\n    /**\n     * let's start a clock\n     */\n\n    setInterval(() => {\n      if (working) {\n        return;\n      }\n\n      working = true;\n      cpu.next();\n      working = false;\n    }, 1000 / this.speed);\n\n    const animateLoop = () => {\n      this.frame = requestAnimationFrame(animateLoop);\n\n      const screen = cpu.display;\n      gfx.paint(screen);\n    };\n\n    /**\n     * Once started the animateLoop function will call itself recursively\n     */\n\n    this.frame = requestAnimationFrame(animateLoop);\n  }\n\n  /**\n   * shut it all down fellas\n   * only call this if you're about to destroy the class\n   * this ensures event listeners and audio loops are destroyed\n   */\n  public stop() {\n    cancelAnimationFrame(this.frame);\n    this.cpu.halt();\n  }\n}\n","import { useState, useEffect, useRef, useCallback } from 'react';\nimport { Field, Form, Formik } from 'formik';\nimport request from 'axios';\nimport isClient from '@bagofholding/is-client';\n\nimport Chip, { games, keypad, instructions } from '../../libs/chip/chip';\n\nimport './App.scss';\n\nfunction App() {\n  const canvas = useRef(null);\n\n  const [slot, setSlot] = useState(games[0].toLowerCase());\n\n  const fetchData = useCallback(async () => {\n    /**\n     * check for any instances of chip before we load a rom\n     */\n    if (window.chip) {\n      window.chip.stop();\n    }\n    /**\n     * sadly superagent does not support blobs in userland\n     * we have retired it here in favour of axios\n     */\n    const response = await request({\n      url: `${process.env.PUBLIC_URL}/roms/${slot}`,\n      method: 'GET',\n      responseType: 'blob'\n    });\n\n    const blob = new Blob([response.data]);\n    const buffer = await blob.arrayBuffer();\n    const rom = new Uint8Array(buffer);\n    const chip = new Chip(slot, rom, canvas);\n\n    window.chip = chip;\n  }, [slot]);\n\n  useEffect(() => {\n    if (isClient() && canvas && canvas?.current) {\n      fetchData();\n    }\n  }, [slot, canvas, fetchData]);\n\n  const handleButtonPress = (key: string) => {\n    if (isClient()) {\n      window.chip.keyboard.press(key);\n\n      /**\n       * we then wait a little time to fake a real keypress\n       * the key needs to be released manually\n       */\n\n      setTimeout(() => {\n        window.chip.keyboard.release();\n      }, 200);\n    }\n  };\n\n  const handleToggleGrid = () => {\n    if (isClient()) {\n      window.chip.gfx.toggleGrid();\n    }\n  };\n\n  return (\n    <div className=\"container app\">\n      <div className=\"row\">\n        <div className=\"col-12 text-center mb-3\">\n          <h1 className=\"mb-0\">CHIP.ts</h1>\n          <h2>\n            <small className=\"text-muted\">\n              A CHIP-8 emulator in TypeScript\n            </small>\n          </h2>\n          <canvas data-testid=\"canvas\" ref={canvas} />\n        </div>\n      </div>\n\n      <div className=\"row\">\n        <div className=\"col-6 text-center mb-2\">\n          <button\n            className=\"btn btn-secondary\"\n            onClick={() => {\n              handleButtonPress('Escape');\n            }}\n          >\n            Pause (Escape / Spacebar)\n          </button>\n        </div>\n        <div className=\"col-6 text-center mb-2\">\n          <button\n            className=\"btn btn-secondary\"\n            onClick={() => {\n              handleToggleGrid();\n            }}\n          >\n            Toggle Grid\n          </button>\n        </div>\n        <div className=\"col-12\">\n          {/** virtual keypad */}\n          {keypad.map((row, i) => (\n            <div key={i} className=\"row\">\n              {row.map((column: string) => (\n                <div key={column} className=\"col-3 text-center mb-2\">\n                  <button\n                    className=\"btn btn-secondary w-100\"\n                    onClick={() => {\n                      handleButtonPress(column);\n                    }}\n                  >\n                    {column.toUpperCase()}\n                  </button>\n                </div>\n              ))}\n            </div>\n          ))}\n        </div>\n      </div>\n\n      {instructions[slot] && (\n        <div className=\"row\">\n          <div className=\"col-12\">\n            <div className=\"alert alert-secondary\" role=\"alert\">\n              <h2>{slot} keys:</h2>\n              {instructions[slot.toLowerCase()]}\n            </div>\n          </div>\n        </div>\n      )}\n      <Formik\n        initialValues={{ slot }}\n        onSubmit={values => {\n          if (values.slot !== slot) {\n            setSlot(values.slot);\n          }\n        }}\n      >\n        <Form className=\"row justify-content-lg-center\">\n          <div className=\"col-12 text-center\">\n            <h3>Choose a cartidge</h3>\n            <Field as=\"select\" className=\"form-control\" name=\"slot\">\n              {games.map(game => (\n                <option key={game} value={game.toLowerCase()}>\n                  {game}\n                </option>\n              ))}\n            </Field>\n            <hr />\n            <button className=\"btn btn-primary\" type=\"submit\">\n              Load\n            </button>\n            <hr />\n            <a\n              className=\"btn btn-light\"\n              href=\"https://github.com/PenguinOfWar/chip.ts\"\n            >\n              View code on GitHub\n            </a>\n          </div>\n        </Form>\n      </Formik>\n    </div>\n  );\n}\n\ndeclare global {\n  interface Window {\n    chip: Chip;\n  }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './containers/App/App';\n\nimport reportWebVitals from './reportWebVitals';\n\nimport './sass/index.scss';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}