{"version":3,"sources":["libs/chip/drivers/cpu.ts","libs/chip/chip.ts","containers/App/App.tsx","reportWebVitals.ts","index.tsx"],"names":["Cpu","rom","memory","Uint8Array","ArrayBuffer","registers","stack","Uint16Array","stackPointer","resolution","x","y","screen","this","counter","load","map","instruction","address","addressMap","opcode","console","log","Chip","fps","frame","start","cpu","then","performance","now","interval","requestAnimationFrame","animateLoop","delta","tick","cancelAnimationFrame","App","useState","booted","setBooted","useEffect","a","request","url","process","method","responseType","response","blob","Blob","data","arrayBuffer","buffer","chip","isClient","fetchData","className","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"sQAOqBA,E,WA2DnB,WAAYC,GAAkB,yBAhDvBC,OAAS,IAAIC,WAAW,IAAIC,YAAY,OAgDlB,KAzCtBC,UAAY,IAAIF,WAAW,IAyCL,KAlCtBG,MAAQ,IAAIC,YAAY,IAkCF,KA5BtBC,aAAe,EA4BO,KArBtBC,WAAa,CAClBC,EAAG,GACHC,EAAG,IAmBwB,KAXtBC,OAAS,IAAIT,WAAWU,KAAKJ,WAAWC,EAAIG,KAAKJ,WAAWE,GAWtC,KAFtBG,QAAU,IAGfD,KAAKE,KAAKd,G,wCAUZ,SAAKA,GAAkB,IAAD,OACpBA,EAAIe,KAAI,SAACC,EAAaC,GAMpB,IAAMC,EAAaD,EAAU,IAI7B,OAFA,EAAKhB,OAAOiB,GAAcF,EAEnBA,O,kBASX,WAQE,IAAMG,EACHP,KAAKX,OAAOW,KAAKC,UAAY,EAAKD,KAAKX,OAAOW,KAAKC,QAAU,GAO1DJ,GAAc,KAATU,IAAoB,EACzBT,GAAc,IAATS,IAAoB,EAE/BC,QAAQC,IAAIT,KAAKC,QAASM,EAAQV,EAAGC,EAAY,MAATS,GAMxCP,KAAKC,SAAW,M,KCjHCS,E,WAUnB,WAAYtB,GAAkB,yBAH9BuB,IAAM,GAGuB,KAF7BC,MAAQ,EAGNZ,KAAKa,MAAM,IAAI1B,EAAIC,I,yCAUrB,SAAM0B,GAAW,IAAD,OAMVC,EAAeC,YAAYC,MAEzBC,EAAW,IAAOlB,KAAKW,IAuB7BX,KAAKY,MAAQO,uBApBO,SAAdC,EAAeH,GACnB,EAAKL,MAAQO,sBAAsBC,GAEnC,IAAMC,EAAQJ,EAAMF,EAEhBM,GAASH,EAPG,KAQdH,EAAOE,EAAOI,EAAQH,EAMtBJ,EAAIQ,a,kBAWV,WACEC,qBAAqBvB,KAAKY,W,oBCZfY,MA5Cf,WAAgB,IAAD,EACeC,oBAAS,GADxB,mBACNC,EADM,KACEC,EADF,KAiCb,OA9BAC,qBAAU,WAAM,4CACd,oCAAAC,EAAA,6DACEF,GAAU,GADZ,SAMyBG,IAAQ,CAC7BC,IAAI,GAAD,OAAKC,WAAL,cACHC,OAAQ,MACRC,aAAc,SATlB,cAMQC,EANR,OAYQC,EAAO,IAAIC,KAAK,CAACF,EAASG,OAZlC,SAauBF,EAAKG,cAb5B,OAaQC,EAbR,OAcQpD,EAAM,IAAIE,WAAWkD,GACrBC,EAAO,IAAI/B,EAAKtB,GAEtBoB,QAAQC,IAAIgC,GAjBd,6CADc,sBAqBVf,GAIAgB,eAzBW,WAAD,wBA0BZC,KAED,CAACjB,IAGF,qBAAKkB,UAAU,gBAAf,SACE,qBAAKA,UAAU,MAAf,SACE,qBAAKA,UAAU,SAAf,SACE,gDChCKC,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBhC,MAAK,YAAkD,IAA/CiC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,O,MCAdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BZ,M","file":"static/js/main.98caee32.chunk.js","sourcesContent":["/**\n *\n * CHIP-8 CPU emulator class\n * @author Darryl Walker\n *\n */\n\nexport default class Cpu {\n  /**\n   * CHIP-8 has 4096 8-bit (1 byte) memory locations\n   * A byte will be the smallest addressable location for this exercise\n   * Each byte can be 0 or 1\n   *\n   * Our 4096 decimal can expressed as 0x1000 in hexadecimal\n   * We will create a new ArrayBuffer and pass it to Uint8Array (unsigned integer with a range of 0-255)\n   * Array buffer will handle our raw data for us e.g. 0x1000 => 4096\n   */\n\n  public memory = new Uint8Array(new ArrayBuffer(0x1000));\n\n  /**\n   * CHIP-8 has 16 8-bit data registers named V0 to VF\n   * We create a new Uint8Array with 16 register locations\n   */\n\n  public registers = new Uint8Array(16);\n\n  /**\n   * Our stack will need to store return addresses\n   * We will need 16 of these 16-bit addresses\n   */\n\n  public stack = new Uint16Array(16);\n\n  /**\n   * Our stack pointer will store where in our 16 length stack we should be\n   */\n\n  public stackPointer = 0;\n\n  /**\n   * Here we configure graphics and sound\n   * CHIP-8 has a display resolution of 64x32\n   */\n\n  public resolution = {\n    x: 64,\n    y: 32\n  };\n\n  /**\n   * Our screen space will be an array representing pixels\n   * left to right, top to bottom, 8-bits (1-byte) each\n   */\n\n  public screen = new Uint8Array(this.resolution.x * this.resolution.y);\n\n  /**\n   * We need to define our program counter\n   * This is the next instruction that should be executed by our cpu\n   * CHIP-8 starts at 0x200 leaving the lowest 512 bytes (0-511) free\n   * We'll store font data there later\n   */\n\n  public counter = 0x200;\n\n  constructor(rom: Uint8Array) {\n    this.load(rom);\n  }\n\n  /**\n   * We take the ROM file represented as a Uint8Array and map into memory\n   * Here we need to ecounter for the original interpreter positions\n   * For this reason, most programs written for the original system begin at memory location 512 (0x200)\n   * We shift all the memory addresses over by 512 (or 0x200 for fun)\n   */\n\n  load(rom: Uint8Array) {\n    rom.map((instruction, address) => {\n      /**\n       * take the instrction and the array index as our memory address\n       * map this into our emulators memory\n       */\n\n      const addressMap = address + 0x200;\n\n      this.memory[addressMap] = instruction;\n\n      return instruction;\n    });\n  }\n\n  /**\n   * Our processor will perform an instruction once per tick\n   * During this time we will check the opcode and see what it needs to do\n   */\n\n  public tick() {\n    /**\n     * This bit is a little confusing to me\n     * I learned a lot of it from reading\n     * https://github.com/alexanderdickson/Chip-8-Emulator/blob/5da6ac6a4753462d02ca7fe8d5a9398308b8d9d0/scripts/chip8.js#L193\n     * We're shifting everything over bitwise 8 to the left\n     * And then doing a bitwise or on each pair of bits. a OR b yields 1 if either a or b is 1.\n     */\n    const opcode =\n      (this.memory[this.counter] << 8) | this.memory[this.counter + 1];\n\n    /**\n     * here a bitwise AND (&) compares two numbers and casts them to numbers if they arent numbers\n     * my head hurts\n     */\n\n    const x = (opcode & 0x0f00) >> 8;\n    const y = (opcode & 0x00f0) >> 4;\n\n    console.log(this.counter, opcode, x, y, opcode & 0xf000);\n\n    /**\n     * increment our counter to move to the next instruction\n     */\n\n    this.counter += 2;\n  }\n}\n","/**\n *\n * CHIP.ts - A CHIP-8 emulator in TypeScript\n * @author Darryl Walker\n *\n */\n\nimport Cpu from './drivers/cpu';\n\nexport default class Chip {\n  /**\n   * Configure our preferred target framerate\n   * We'll also configure our frame pointer and play state\n   * Timing function from https://gist.github.com/addyosmani/5434533#gistcomment-2018050\n   */\n\n  fps = 60;\n  frame = 0;\n\n  constructor(rom: Uint8Array) {\n    this.start(new Cpu(rom));\n  }\n\n  /**\n   * start will kick off our timing function\n   * this is going to check 60 times per second\n   * requestAnimationFrame is a browser API that helps us\n   * with render timing\n   */\n\n  start(cpu: Cpu) {\n    /**\n     * I just learned about performance\n     * This is cool\n     */\n\n    let then: number = performance.now();\n\n    const interval = 1000 / this.fps;\n    const tolerance = 0.1;\n\n    const animateLoop = (now: number) => {\n      this.frame = requestAnimationFrame(animateLoop);\n\n      const delta = now - then;\n\n      if (delta >= interval - tolerance) {\n        then = now - (delta % interval);\n\n        /**\n         * Code within this block is executed once per frame\n         */\n\n        cpu.tick();\n      }\n    };\n\n    /**\n     * Once started the animateLoop function will call itself recursively\n     */\n\n    this.frame = requestAnimationFrame(animateLoop);\n  }\n\n  stop() {\n    cancelAnimationFrame(this.frame);\n  }\n}\n","import { useState, useEffect } from 'react';\nimport isClient from '@bagofholding/is-client';\n\nimport request from 'axios';\n\nimport Chip from '../../libs/chip/chip';\n\nimport './App.scss';\n\nfunction App() {\n  const [booted, setBooted] = useState(false);\n\n  useEffect(() => {\n    async function fetchData() {\n      setBooted(true);\n      /**\n       * sadly superagent does not support blobs in userland\n       * we have retired it here in favour of axios\n       */\n      const response = await request({\n        url: `${process.env.PUBLIC_URL}/roms/pong`,\n        method: 'GET',\n        responseType: 'blob'\n      });\n\n      const blob = new Blob([response.data]);\n      const buffer = await blob.arrayBuffer();\n      const rom = new Uint8Array(buffer);\n      const chip = new Chip(rom);\n\n      console.log(chip);\n    }\n\n    if (booted) {\n      return;\n    }\n\n    if (isClient()) {\n      fetchData();\n    }\n  }, [booted]);\n\n  return (\n    <div className=\"container app\">\n      <div className=\"row\">\n        <div className=\"col-12\">\n          <h1>CHIP.ts</h1>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './containers/App/App';\n\nimport reportWebVitals from './reportWebVitals';\n\nimport './sass/index.scss';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}