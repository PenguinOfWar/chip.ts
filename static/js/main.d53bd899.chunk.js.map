{"version":3,"sources":["polyfills/arrayBuffer.js","libs/chip/assets/characters.ts","libs/chip/drivers/cpu.ts","libs/chip/drivers/gfx.ts","libs/chip/drivers/keyboard.ts","libs/chip/chip.ts","components/DebugArrayTable/views/StackView/StackView.tsx","components/DebugArrayTable/DebugArrayTable.tsx","containers/App/App.tsx","reportWebVitals.ts","index.tsx"],"names":["arrayBuffer","_this","Promise","resolve","fr","FileReader","onload","result","readAsArrayBuffer","fonts","AudioContext","window","webkitAudioContext","Cpu","rom","gfx","_classCallCheck","memory","Uint8Array","ArrayBuffer","registers","stack","Uint16Array","stackPointer","counter","pointer","screen","delayTimer","soundTimer","keys","key","speaker","wave","running","this","resolution","x","y","load","_createClass","value","loadFont","map","instruction","address","addressMap","start","_this2","char","index","dispatch","context","tick","_objectSpread","cpu","beep","opcode","NN","JUMP","didJump","disp_clear","console","warn","Error","concat","toString","Math","floor","random","spr","height","coordinates","vertical","horizontal","scale","setPixel","stop","pointers","i","get","width","location","display","oscillator","createOscillator","connect","destination","type","setTimeout","close","Gfx","canvas","colors","background","foreground","grid","gridNode","undefined","current","boot","getContext","DOMURL","URL","webkitURL","img","Image","svg","Blob","url","createObjectURL","drawImage","revokeObjectURL","src","_this$gridNode","_this$gridNode$parent","parentNode","removeChild","pixel","position","fillStyle","strokeStyle","fillRect","Keyboard","listen","input","document","addEventListener","event","press","release","games","keypad","instructions","brix","tetris","pong","ufo","ibm","invaders","missile","tank","maze","Chip","game","speed","frame","keyboard","specialCases","bind","toLowerCase","CustomEvent","Function","data","cpuEvent","detail","dispatchEvent","working","setInterval","next","requestAnimationFrame","animateLoop","paint","cancelAnimationFrame","halt","StackView","props","array","Array","from","length","_jsxs","className","children","_jsx","_item","item","DebugArrayTable","format","scope","App","_debugDetail$cpu","_debugDetail$cpu2","_debugDetail$cpu3","_debugDetail$cpu4","_debugDetail$cpu5","_debugDetail$cpu6","_debugDetail$cpu7","_debugDetail$cpu8","_debugDetail$cpu9","useRef","_useState","useState","_useState2","_slicedToArray","slot","setSlot","_useState3","_useState4","debugDetail","setDebugDetail","fetchData","useCallback","_asyncToGenerator","_regeneratorRuntime","mark","_callee","response","blob","buffer","chip","wrap","_context","prev","request","process","method","responseType","sent","File","prototype","useEffect","isClient","handleButtonPress","handleDebugListener","log","removeEventListener","ref","onClick","toggleGrid","row","column","toUpperCase","role","Formik","initialValues","onSubmit","values","Form","Field","as","name","Object","Collapsible","trigger","triggerTagName","triggerClassName","triggerOpenedClassName","String","href","reportWebVitals","onPerfEntry","then","_ref","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","React","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.d53bd899.chunk.js","sourcesContent":["// Source: https://gist.github.com/hanayashiki/8dac237671343e7f0b15de617b0051bd\n\nfunction arrayBuffer() {\n  // this: File or Blob\n  return new Promise(resolve => {\n    let fr = new FileReader();\n    fr.onload = () => {\n      resolve(fr.result);\n    };\n    fr.readAsArrayBuffer(this);\n  });\n}\n\nexport default arrayBuffer;\n","export const fonts = [\n  0xf0,\n  0x90,\n  0x90,\n  0x90,\n  0xf0, // 0\n  0x20,\n  0x60,\n  0x20,\n  0x20,\n  0x70, // 1\n  0xf0,\n  0x10,\n  0xf0,\n  0x80,\n  0xf0, // 2\n  0xf0,\n  0x10,\n  0xf0,\n  0x10,\n  0xf0, // 3\n  0x90,\n  0x90,\n  0xf0,\n  0x10,\n  0x10, // 4\n  0xf0,\n  0x80,\n  0xf0,\n  0x10,\n  0xf0, // 5\n  0xf0,\n  0x80,\n  0xf0,\n  0x90,\n  0xf0, // 6\n  0xf0,\n  0x10,\n  0x20,\n  0x40,\n  0x40, // 7\n  0xf0,\n  0x90,\n  0xf0,\n  0x90,\n  0xf0, // 8\n  0xf0,\n  0x90,\n  0xf0,\n  0x10,\n  0xf0, // 9\n  0xf0,\n  0x90,\n  0xf0,\n  0x90,\n  0x90, // A\n  0xe0,\n  0x90,\n  0xe0,\n  0x90,\n  0xe0, // B\n  0xf0,\n  0x80,\n  0x80,\n  0x80,\n  0xf0, // C\n  0xe0,\n  0x90,\n  0x90,\n  0x90,\n  0xe0, // D\n  0xf0,\n  0x80,\n  0xf0,\n  0x80,\n  0xf0, // E\n  0xf0,\n  0x80,\n  0xf0,\n  0x80,\n  0x80 // F\n];\n","/**\n *\n * CHIP-8 CPU emulator class\n * @author Darryl Walker\n *\n */\n\nimport Gfx from './gfx';\nimport { fonts } from '../assets/characters';\nimport { IChip, IChipContext } from '../types/chip.types';\n\nconst AudioContext = window.AudioContext || window.webkitAudioContext;\n\nexport default class Cpu {\n  /**\n   * CHIP-8 has 4096 8-bit (1 byte) memory locations\n   * A byte is normally the smallest addressable location\n   * Each byte can be a value of 0-255\n   *\n   * Our 4096 decimal can expressed as 0x1000 in hexadecimal\n   * We will create a new ArrayBuffer and pass it to Uint8Array (unsigned integer with a range of 0-255)\n   * Array buffer will handle our raw data for us e.g. 0x1000 => 4096\n   */\n\n  memory = new Uint8Array(new ArrayBuffer(0x1000));\n\n  /**\n   * CHIP-8 has 16 8-bit data registers named V0 to VF\n   * We create a new Uint8Array with 16 register locations\n   */\n\n  registers = new Uint8Array(16);\n\n  /**\n   * Our stack will need to store return addresses\n   * We will need 16 of these 16-bit addresses\n   */\n\n  stack = new Uint16Array(16);\n\n  /**\n   * Our stack pointer will store where in our 16 length stack we should be\n   */\n\n  stackPointer = 0;\n\n  /**\n   * We need to define our program counter\n   * This is the next instruction that should be executed by our cpu\n   * CHIP-8 starts at 0x200 leaving the lowest 512 bytes (0-511) free\n   * We'll store font data there later\n   */\n\n  counter = 0x200;\n\n  /**\n   * Assign a position for our graphics adapter\n   */\n\n  gfx;\n\n  /**\n   * okay so this is a pointer i've called pointer\n   * in reality it's confusingly called \"I\"\n   * i like mine better for now\n   * on the CHIP-8 it's a 16-bit register so a regular number is fine\n   */\n\n  pointer = 0;\n\n  /**\n   * Our screen space will be an array representing pixels\n   * left to right, top to bottom, 8-bits (1-byte) each\n   */\n\n  public screen = new Uint8Array();\n\n  /**\n   * we have two timers- one for delay and one for sound\n   */\n\n  delayTimer = 0;\n  soundTimer = 0;\n\n  /**\n   * Keypad - used as input from a HEX keypad\n   */\n\n  keys: IKeys = {};\n\n  /**\n   * at any given time we can have one key pressed\n   * so we'll keep track of it via a pointer\n   */\n\n  key = 0;\n\n  /**\n   * we will also need a virtual keyboard and sound adapter\n   */\n\n  speaker = new AudioContext();\n  wave: OscillatorType = 'sawtooth';\n\n  /**\n   * We need a way to track whether or not ops should be paused\n   * a boolean will do\n   */\n\n  public running = false;\n\n  constructor(rom: Uint8Array, gfx: Gfx) {\n    this.gfx = gfx;\n    this.screen = new Uint8Array(this.gfx.resolution.x * this.gfx.resolution.y);\n    this.load(rom);\n  }\n\n  /**\n   * We take the ROM file represented as a Uint8Array and map into memory\n   * Here we need to ecounter for the original interpreter positions\n   * For this reason, most programs written for the original system begin at memory location 512 (0x200)\n   * We shift all the memory addresses over by 512 (or 0x200 for fun)\n   */\n\n  load(rom: Uint8Array) {\n    /**\n     * load fonts first\n     */\n\n    this.loadFont();\n\n    rom.map((instruction, address) => {\n      /**\n       * take the instrction and the array index as our memory address\n       * map this into our emulators memory\n       */\n\n      const addressMap = address + 0x200;\n\n      this.memory[addressMap] = instruction;\n\n      return instruction;\n    });\n\n    /**\n     * it's always useful if you remember to start the engine\n     */\n    this.start();\n  }\n\n  /**\n   * We need to load a hexadecimal character set into the first few bytes of our memory\n   * we have 512 free slots to play with in total\n   */\n  loadFont() {\n    return fonts.map((char, index) => {\n      return (this.memory[index] = char);\n    });\n  }\n\n  public start() {\n    this.running = true;\n  }\n\n  public stop() {\n    this.running = false;\n  }\n\n  /**\n   * We will provided a handle little API for the chip to call for a tick at the preferred rate\n   * next will check if the cpu is running and tick if true\n   */\n\n  public next(dispatch: Function, context: IChipContext) {\n    if (!this.running) {\n      return;\n    }\n\n    this.tick();\n\n    const buildContext: IChip = {\n      ...context,\n      cpu: {\n        counter: this.counter,\n        delayTimer: this.delayTimer,\n        key: this.key,\n        memory: this.memory,\n        pointer: this.pointer,\n        registers: this.registers,\n        running: this.running,\n        screen: this.screen,\n        soundTimer: this.soundTimer,\n        stack: this.stack,\n        stackPointer: this.stackPointer\n      }\n    };\n\n    dispatch(buildContext);\n  }\n\n  /**\n   * Our processor will perform an instruction once per tick\n   * During this time we will check the opcode and see what it needs to do\n   */\n\n  tick() {\n    /**\n     * before we do anything we have to decrement our timers\n     */\n\n    if (this.delayTimer > 0) {\n      --this.delayTimer;\n    }\n\n    if (this.soundTimer > 0) {\n      /**\n       * if the sound timer is exactly 1 fire a beep off\n       */\n      if (this.running && this.soundTimer === 1) {\n        this.beep();\n      }\n\n      --this.soundTimer;\n    }\n\n    /**\n     * This bit is a little confusing to me\n     * I learned a lot of it from reading\n     * https://github.com/alexanderdickson/Chip-8-Emulator/blob/5da6ac6a4753462d02ca7fe8d5a9398308b8d9d0/scripts/chip8.js#L193\n     * We're shifting everything over bitwise 8 to the left\n     * And then doing a bitwise or on each pair of bits. a OR b yields 1 if either a or b is 1.\n     *\n     * UPDATE\n     * Bless this dude, who seems to be the reference for the above JS dude/dudette\n     * https://github.com/eshyong/Chip-8-Emulator/blob/master/chip8.c\n     *\n     * Opcodes are two bytes long!\n     * We're creating a hexidecimal here, I guess? Out of the two byte opcode\n     *\n     * here we take the first complete bite\n     * in pongs case that's 6A hex / 106 decimalÎ\n     * we also take the next byte which is conveniently 02 hex / 2 decimal\n     *\n     * fuck me\n     * i guess this is a clever way of storing integers greater than 8 bits\n     * which is cool as shit\n     *\n     * we take decimal 106 and we shift it left 8 places giving us decimal 27136\n     *\n     * then we take output of that left shift and give it to a bitwise OR - the single pipe dude\n     * this guy adds them together\n     * problem: 27136 | 2\n     * result: 27138 decimal / 6a02 hex\n     *\n     * i guess we just got two bytes of storage out of one byte of data\n     * how very... bitwise\n     *\n     */\n\n    const opcode =\n      (this.memory[this.counter] << 8) | this.memory[this.counter + 1];\n\n    /**\n     * here a bitwise AND (&) compares two numbers and casts them to numbers if they arent numbers\n     * my head hurts\n     *\n     * Read here:\n     * https://en.wikipedia.org/wiki/Bitwise_operation#AND\n     *\n     * Okay.\n     * There's a lot going on here.\n     * X is a two parter, first we take our opcode 27136 and give it 0x0f00 hex / 3840 decimal\n     * this yields a00 hex / 2560 decimal\n     *\n     * we then shift the result over 8 places right yielding a hex / 10 decimal\n     * giving us our register address for later!\n     *\n     * do similar for y taking 27136 and giving it 0x0000 hex / 0 decimal and go god i keep flopping back and forth\n     * it's all hex i swear just different hex and i will tidy it up just look at the decimals\n     *\n     * shift it over 4 and it's still 0 / 0x0000\n     *\n     */\n\n    const x = (opcode & 0x0f00) >> 8;\n    const y = (opcode & 0x00f0) >> 4;\n    const NN = opcode & 0x00ff;\n    const JUMP = opcode & 0x0fff;\n    let didJump = false;\n\n    /**\n     * then start checking opcodes\n     *\n     * our first check is the result of opcode AND 0xf000\n     * continuing with the above we have 27138 & 61440 = 24576 decimal / 0x6000 hex\n     *\n     * this corresponds to opcode 6XNN!\n     * https://en.wikipedia.org/wiki/CHIP-8#Opcode_table\n     *\n     * this is called checking the first nibble of the byte\n     */\n\n    switch (opcode & 0xf000) {\n      /**\n       * 0000\n       * This can be a few things but we only really care about two of them - 00E0 and 00EE\n       */\n      case 0x0000: {\n        switch (opcode) {\n          /**\n           * 00E0 / disp_clear() - clears the screen\n           */\n          case 0x00e0:\n            this.disp_clear();\n            break;\n\n          /**\n           * 00EE / return from a subroutine\n           */\n          case 0x00ee:\n            if (this.stack[this.stackPointer] === 0) {\n              console.warn('Invalid return from subroutine.');\n            }\n\n            this.counter = this.stack[this.stackPointer];\n            this.stack[this.stackPointer] = 0;\n\n            if (this.stackPointer > 0) {\n              --this.stackPointer;\n            }\n            break;\n        }\n        break;\n      }\n\n      /**\n       * 1NNN - Jumps to address NNN.\n       */\n      case 0x1000: {\n        this.counter = JUMP;\n        didJump = true;\n        break;\n      }\n\n      /**\n       * 2NNN - Calls subroutine at NNN.\n       * Updates the counter to the next instruction\n       * We store the return address for later and increment our stack size\n       */\n      case 0x2000: {\n        if (this.stack[this.stackPointer] !== 0) {\n          ++this.stackPointer;\n        }\n        this.stack[this.stackPointer] = this.counter;\n        this.counter = JUMP;\n        didJump = true;\n        break;\n      }\n\n      /**\n       * 3XNN/if(Vx==NN) - Skips the next instruction if VX equals NN. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x3000: {\n        if (this.registers[x] === NN) {\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * 4XNN/if(Vx!=NN - Skips the next instruction if VX doesn't equal NN. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x4000: {\n        if (this.registers[x] !== NN) {\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * 5XY0/if(Vx==Vy) - Skips the next instruction if VX equals VY. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x5000: {\n        if (this.registers[x] === this.registers[y]) {\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * 6XNN - Sets VX to NN\n       * opcode AND 0xFF hex / 255 dec = 2 dec / 02 hex\n       * therefore register 10 now has a value of two\n       */\n      case 0x6000: {\n        this.registers[x] = opcode & 0xff;\n        break;\n      }\n\n      /**\n       * 7XNN - Adds NN to VX. (Carry flag is not changed)\n       */\n      case 0x7000: {\n        this.registers[x] += NN;\n        break;\n      }\n\n      /**\n       * 8000 is an imposing list of VX and VY operations\n       */\n\n      case 0x8000: {\n        switch (opcode & 0x000f) {\n          /**\n           * 8XY0/Vx=Vy - Sets VX to the value of VY.\n           */\n          case 0x0000: {\n            this.registers[x] = this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY1/Vx=Vx|Vy - Sets VX to VX or VY. (Bitwise OR operation)\n           */\n          case 0x0001: {\n            this.registers[x] = this.registers[x] | this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY2/Vx=Vx&Vy - Sets VX to VX and VY. (Bitwise AND operation)\n           */\n          case 0x0002: {\n            this.registers[x] = this.registers[x] & this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY3/Vx=Vx^Vy - Sets VX to VX xor VY.\n           */\n          case 0x0003: {\n            this.registers[x] = this.registers[x] ^ this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY4/Vx += Vy - Adds VY to VX. VF is set to 1 when there's a carry, and to 0 when there isn't.\n           */\n          case 0x0004: {\n            if (this.registers[x] + this.registers[y] > 255) {\n              this.registers[0xf] = 1;\n            } else {\n              this.registers[0xf] = 0;\n            }\n            this.registers[x] += this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY5/Vx -= Vy - VY is subtracted from VX. VF is set to 0 when there's a borrow, and 1 when there isn't.\n           */\n          case 0x0005: {\n            if (this.registers[x] < this.registers[y]) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] -= this.registers[y];\n            break;\n          }\n\n          /**\n           * 8XY6/Vx>>=1 - Stores the least significant bit of VX in VF and then shifts VX to the right by 1.\n           */\n          case 0x0006: {\n            if (this.registers[x] % 2 === 0) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] = this.registers[x] >> 1;\n            break;\n          }\n\n          /**\n           * 8XY7/Vx=Vy-Vx - Sets VX to VY minus VX. VF is set to 0 when there's a borrow, and 1 when there isn't.\n           */\n          case 0x0007: {\n            if (this.registers[y] < this.registers[x]) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] = this.registers[y] - this.registers[x];\n            break;\n          }\n\n          /**\n           * 8XYE/Vx<<=1 - Stores the most significant bit of VX in VF and then shifts VX to the left by 1\n           */\n          case 0x000e: {\n            if (this.registers[x] < 128) {\n              this.registers[0xf] = 0;\n            } else {\n              this.registers[0xf] = 1;\n            }\n            this.registers[x] = this.registers[x] << 1;\n            break;\n          }\n          default: {\n            throw new Error(\n              `Unknown opcode in 8000 block: ${opcode.toString(16)}`\n            );\n          }\n        }\n        break;\n      }\n\n      /**\n       * we (i) forgot about instruction 9\n       * 9XY0/if(Vx!=Vy) - Skips the next instruction if VX doesn't equal VY. (Usually the next instruction is a jump to skip a code block)\n       */\n      case 0x9000: {\n        // skip next instruction if VX not equals VY\n        if (this.registers[x] !== this.registers[y]) {\n          this.counter += 2;\n        }\n        break;\n      }\n\n      /**\n       * ANNN - Sets pointer/I to address NNN\n       */\n      case 0xa000: {\n        this.pointer = JUMP;\n        break;\n      }\n\n      /**\n       * BNNN - Jumps to addres that is sum of NNN and V0 (register 0)\n       */\n      case 0xb000: {\n        this.counter = (opcode & 0xfff) + this.registers[0];\n        didJump = true;\n        break;\n      }\n\n      /**\n       * CXNN/Vx=rand()&N - Sets VX to the result of a bitwise and operation on a random number (Typically: 0 to 255) and NN.\n       */\n      case 0xc000: {\n        this.registers[x] = Math.floor(Math.random() * 255) % 255 & NN;\n        break;\n      }\n\n      /**\n       * DXYN / draw(Vx,Vy,N) - Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N+1 pixels.\n       */\n      case 0xd000: {\n        const height = opcode & 0x000f;\n\n        /**\n         * get our x and y coordinates from our register\n         * use values at position VX and VY\n         */\n\n        let coordinates: ICoordinates = {\n          x: this.registers[x],\n          y: this.registers[y]\n        };\n\n        // set carry flag to 0\n        this.registers[0xf] = 0;\n\n        let spr;\n\n        /**\n         * drawing loop\n         * try not to get it backwards like i did\n         */\n        for (let vertical = 0; vertical < height; vertical++) {\n          spr = this.memory[this.pointer + vertical];\n\n          for (\n            let horizontal = 0;\n            horizontal < this.gfx.resolution.scale;\n            horizontal++\n          ) {\n            if (coordinates.x + horizontal === this.gfx.resolution.x) {\n              coordinates.x = -horizontal;\n            }\n            if (coordinates.y + vertical === this.gfx.resolution.y) {\n              coordinates.y = -vertical;\n            }\n\n            if ((spr & 0x80) > 0) {\n              if (\n                this.setPixel(\n                  this.registers[x] + horizontal,\n                  this.registers[y] + vertical\n                )\n              ) {\n                this.registers[0xf] = 1;\n              }\n            }\n            spr <<= 1;\n          }\n          coordinates.x = this.registers[x];\n          coordinates.y = this.registers[y];\n        }\n\n        break;\n      }\n\n      /**\n       * E000 can be one of two things, both bound to key presses\n       * they are kind of the opposite of one another\n       */\n      case 0xe000: {\n        switch (NN) {\n          /**\n           * EX9E/if(key()==Vx) - Skips the next instruction if the key stored in VX is pressed. (Usually the next instruction is a jump to skip a code block)\n           */\n          case 0x009e: {\n            if (this.key === this.registers[x]) {\n              this.counter += 2;\n            }\n            break;\n          }\n\n          /**\n           * EXA1/if(key()!=Vx) - Skips the next instruction if the key stored in VX isn't pressed. (Usually the next instruction is a jump to skip a code block)\n           */\n          case 0x00a1: {\n            if (this.key !== this.registers[x]) {\n              this.counter += 2;\n            }\n            break;\n          }\n          default: {\n            throw new Error(\n              `Unknown opcode in e000 block: ${opcode.toString(16)}`\n            );\n          }\n        }\n        break;\n      }\n\n      /**\n       * ol mate F000 can be a few things\n       */\n      case 0xf000: {\n        switch (NN) {\n          /**\n           * FX07/get_delay() -\tSets VX to the value of the delay timer.\n           */\n          case 0x0007: {\n            this.registers[x] = this.delayTimer;\n            break;\n          }\n          /**\n           * FX0A/get_key() - A key press is awaited, and then stored in VX. (Blocking Operation. All instruction halted until next key event)\n           * What this means is we are actually going to halt the program and wait until a key is pressed\n           */\n          case 0x000a: {\n            if (this.key === 0) {\n              this.stop();\n              return;\n            } else {\n              /**\n               * before we start again should we clear the screen ram and pause the rendering there too?\n               */\n              this.registers[x] = this.key;\n              this.start();\n              break;\n            }\n          }\n\n          /**\n           * FX15/delay_timer(Vx) - Sets the delay timer to VX.\n           */\n          case 0x0015: {\n            this.delayTimer = this.registers[x];\n            break;\n          }\n\n          /**\n           * FX18/sound_timer(Vx) - Sets the sound timer to VX.\n           */\n          case 0x0018: {\n            this.soundTimer = this.registers[x];\n            break;\n          }\n\n          /**\n           * X1E - Adds VX to pointer/I. VF is not affected\n           */\n          case 0x001e: {\n            this.pointer += this.registers[x];\n            break;\n          }\n\n          /**\n           * FX29 - I=sprite_addr[Vx] - Sets I to the location of the sprite for the character in VX.\n           * Characters 0-F (in hexadecimal) are represented by a 4x5 font.\n           * we multiply by 5 to get there\n           */\n          case 0x0029: {\n            this.pointer = this.registers[x] * 5;\n            break;\n          }\n\n          /**\n           * FX33/set_BCD - Stores the binary-coded decimal representation of VX, with the most significant of\n           * three digits at the address in I, the middle digit at I plus 1, and the least significant digit at\n           * I plus 2. (In other words, take the decimal representation of VX, place the hundreds digit in memory\n           * at location in I, the tens digit at location I+1, and the ones digit at location I+2.)\n           */\n          case 0x0033: {\n            const pointers = [\n              this.registers[x] / 100,\n              (this.registers[x] / 10) % 10,\n              this.registers[x] % 10\n            ];\n            this.memory[this.pointer] = pointers[0];\n            this.memory[this.pointer + 1] = pointers[1];\n            this.memory[this.pointer + 2] = pointers[2];\n            break;\n          }\n\n          /**\n           * FX55/reg_dump(Vx,&I) - Stores V0 to VX (including VX) in memory starting at address I.\n           */\n          case 0x0055: {\n            for (let i = 0; i <= x; i++) {\n              this.memory[this.pointer + i] = this.registers[i];\n            }\n            break;\n          }\n\n          /**\n           * FX65/reg_load(Vx,&I) - Fills V0 to VX (including VX) with values from memory starting at address I.\n           */\n          case 0x0065: {\n            for (let i = 0; i <= x; i++) {\n              this.registers[i] = this.memory[this.pointer + i];\n            }\n            this.pointer = this.pointer + x + 1;\n            break;\n          }\n        }\n        break;\n      }\n      default: {\n        throw new Error(`Unknown opcode: ${opcode.toString(16)}`);\n      }\n    }\n\n    /**\n     * all of our instructions are two bytes long\n     * increment our counter+2 to move to the next instruction by default\n     */\n\n    if (!didJump) {\n      this.counter += 2;\n    }\n  }\n\n  get display() {\n    return this.screen;\n  }\n\n  /**\n   * do our set pixel handling here\n   */\n  setPixel(x: number, y: number) {\n    const width = this.gfx.resolution.x;\n    const height = this.gfx.resolution.y;\n\n    // If the pixel exceeds the dimensions,\n    // wrap it back around.\n    if (x > width) {\n      x -= width;\n    } else if (x < 0) {\n      x += width;\n    }\n\n    if (y > height) {\n      y -= height;\n    } else if (y < 0) {\n      y += height;\n    }\n\n    const location = x + y * width;\n\n    this.display[location] ^= 1;\n\n    return !this.screen[location];\n  }\n\n  /**\n   * provide a public api for the keyboard drive to update the key pressed\n   */\n  public input(key: any) {\n    this.key = key;\n  }\n\n  /**\n   * CHIP-8 has a single voice speaker to beep at you\n   * we'll make a beep method for our cpu (or anyone) to use\n   */\n  public beep() {\n    if (this.speaker) {\n      const oscillator = this.speaker.createOscillator();\n      oscillator.connect(this.speaker.destination);\n      /**\n       * i think sawtooth sounds the most retro and its my code so we're sticking with it\n       * there also seems to be an issue here with the oscillator context hanging around\n       * cant quite figure out how to close it gracefully\n       */\n      oscillator.type = this.wave;\n      oscillator.start();\n      setTimeout(() => {\n        oscillator.stop();\n      }, 100);\n      return;\n    }\n  }\n\n  /**\n   * We need to add a halt procedure here primarily to close the audiocontext\n   * it gets really annoying otherwise as sound loops can get stuck in the browser window\n   * dont ask me how i know this\n   */\n\n  public halt() {\n    if (this.speaker) {\n      this.speaker.close();\n    }\n  }\n\n  /**\n   * clear the display\n   */\n  public disp_clear() {\n    /**\n     * feed our paint method an empty screen array and force a new paint\n     */\n\n    const screen = new Uint8Array(\n      this.gfx.resolution.x * this.gfx.resolution.y\n    );\n    this.screen = screen;\n  }\n}\n\nexport interface ICoordinates {\n  x: number;\n  y: number;\n}\n\nexport interface IKeys {\n  [key: number]: any;\n}\n","/**\n *\n * CHIP.ts canvas render methods\n * @author Darryl Walker\n *\n */\n\nexport default class Gfx {\n  /**\n   * we get 2 whole colours to play with here\n   * our background will be black and our foreground classic monochrome green\n   */\n\n  colors = {\n    background: '#000',\n    foreground: '#00ff00'\n  };\n\n  /**\n   * This class will receive input from a buffer and draw a new screen\n   * Canvas is convenient and cool so we'll use that\n   */\n\n  canvas: any = null;\n  context: CanvasRenderingContext2D | null = null;\n  grid = false;\n  gridNode?: HTMLImageElement = undefined;\n\n  /**\n   * Here we configure graphics information\n   * CHIP-8 has a display resolution of 64x32 and we'll scale it up 8 times\n   * Our poor renderer is bound to his resolution forever :(\n   */\n\n  public resolution = {\n    x: 64,\n    y: 32,\n    scale: 8\n  };\n\n  /**\n   * giving up and resorting to any type\n   * seems to work now\n   * we'll assign our canvas to a local property\n   */\n\n  constructor(canvas: any) {\n    this.canvas = canvas.current;\n    this.boot();\n  }\n\n  public toggleGrid() {\n    this.grid = !this.grid;\n  }\n\n  /**\n   * Some basic canvas stuff here we're going to get a 2d canvas context\n   * we're going to give the canvas height and width dimension * scale\n   */\n\n  boot() {\n    this.context = this.canvas.getContext('2d');\n    this.canvas.width = this.resolution.x * this.resolution.scale;\n    this.canvas.height = this.resolution.y * this.resolution.scale;\n  }\n\n  public drawGrid() {\n    if (this.context && this.grid) {\n      const context = this.context;\n\n      const data = `<svg width=\"100%\" height=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"> \n        <defs> \n            <pattern id=\"smallGrid\" width=\"8\" height=\"8\" patternUnits=\"userSpaceOnUse\"> \n                <path d=\"M 8 0 L 0 0 0 8\" fill=\"none\" stroke=\"gray\" stroke-width=\"0.5\" /> \n            </pattern> \n            <pattern id=\"grid\" width=\"80\" height=\"80\" patternUnits=\"userSpaceOnUse\"> \n                <rect width=\"80\" height=\"80\" fill=\"url(#smallGrid)\" /> \n                <path d=\"M 80 0 L 0 0 0 80\" fill=\"none\" stroke=\"gray\" stroke-width=\"1\" /> \n            </pattern> \n        </defs> \n        <rect width=\"100%\" height=\"100%\" fill=\"url(#smallGrid)\" /> \n    </svg>`;\n\n      const DOMURL = window.URL || window.webkitURL || window;\n\n      const img = new Image();\n      const svg = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });\n      const url = DOMURL.createObjectURL(svg);\n\n      img.onload = function () {\n        context.drawImage(img, 0, 0);\n        DOMURL.revokeObjectURL(url);\n      };\n      img.src = url;\n\n      this.gridNode = img;\n    } else {\n      this.gridNode?.parentNode?.removeChild(this.gridNode);\n    }\n  }\n\n  public paint(screen: Uint8Array) {\n    if (this.context) {\n      const context = this.context;\n      const resolution = this.resolution;\n\n      screen.map((pixel, position) => {\n        /**\n         * return the remainder of the position and multiply it by our scale to get our x/y position\n         */\n        const x = (position % resolution.x) * resolution.scale;\n        const y = Math.floor(position / resolution.x) * resolution.scale;\n\n        /**\n         * our pixel is either on or off (0 or 1) so here we present an array with two options\n         * off is 0 or background color\n         * on is 1 or foreground color\n         */\n\n        context.fillStyle = [this.colors.background, this.colors.foreground][\n          pixel\n        ];\n\n        context.strokeStyle = [this.colors.background, this.colors.foreground][\n          pixel\n        ];\n\n        /**\n         * at our x and y coordinate paint a a square matching our scale size and fill color\n         */\n\n        context.fillRect(x, y, this.resolution.scale, this.resolution.scale);\n\n        return pixel;\n      });\n    }\n  }\n}\n","/**\n *\n * CHIP-8 keyboard adapter\n * @author Darryl Walker\n *\n */\n\nimport Cpu from './cpu';\n\nexport default class Keyboard {\n  /**\n   * make a slot for our cpu\n   */\n\n  cpu;\n\n  /**\n   * we need to map keys from a modern keyboard to the 16-key one CHIP-8 suppors\n   */\n\n  constructor(cpu: Cpu) {\n    this.cpu = cpu;\n    this.listen();\n  }\n\n  public press(key: string) {\n    let input;\n\n    /**\n     * use switch to listen for the keys we care about\n     */\n\n    switch (key) {\n      /**\n       * pause / unpause when esc/spacebar is pressed\n       */\n      case ' ':\n      case 'Escape': {\n        if (this.cpu.running) {\n          this.cpu.stop();\n        } else {\n          this.cpu.start();\n        }\n        break;\n      }\n      /**\n       * below inputs are mapped to the hex pad\n       * we'll copy this guy because i cant think of a better way\n       * https://github.com/eshyong/Chip-8-Emulator\n       * |1|2|3|C|\t\t=>\t\t|1|2|3|4|\n       * |4|5|6|D|\t\t=>\t\t|Q|W|E|R|\n       * |7|8|9|E|\t\t=>\t\t|A|S|D|F|\n       * |A|0|B|F|\t\t=>\t\t|Z|X|C|V|\n       */\n      case '1': {\n        input = 0x0001;\n        break;\n      }\n      case '2': {\n        input = 0x0002;\n        break;\n      }\n      case '3': {\n        input = 0x0003;\n        break;\n      }\n      case '4': {\n        input = 0x000c;\n        break;\n      }\n      case 'q': {\n        input = 0x0004;\n        break;\n      }\n      case 'w': {\n        input = 0x0005;\n        break;\n      }\n      case 'e': {\n        input = 0x0006;\n        break;\n      }\n      case 'r': {\n        input = 0x000d;\n        break;\n      }\n      case 'a': {\n        input = 0x0007;\n        break;\n      }\n      case 's': {\n        input = 0x0008;\n        break;\n      }\n      case 'd': {\n        input = 0x0009;\n        break;\n      }\n      case 'f': {\n        input = 0x000e;\n        break;\n      }\n      case 'z': {\n        input = 0x000a;\n        break;\n      }\n      case 'x': {\n        input = 0x0000;\n        break;\n      }\n      case 'c': {\n        input = 0x000b;\n        break;\n      }\n      case 'v': {\n        input = 0x000f;\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n\n    /**\n     * pass the input to the cpu\n     */\n\n    if (input) {\n      this.cpu.input(input);\n    }\n  }\n\n  public release() {\n    this.cpu.input(0);\n  }\n\n  listen() {\n    if (this.cpu) {\n      document.addEventListener('keydown', event => {\n        const { key } = event;\n\n        this.press(key);\n      });\n\n      /**\n       * listen for keyup and clear the key register\n       * send it 0 if we're clear because why on earth should it be anything but\n       * note to self: when consulting the ancient texts they are not 1-2-1 gospel. ta.\n       */\n      document.addEventListener('keyup', () => {\n        this.release();\n      });\n    }\n  }\n}\n","/**\n *\n * CHIP.ts - A CHIP-8 emulator in TypeScript\n * @author Darryl Walker\n *\n */\n\nimport Cpu from './drivers/cpu';\nimport Gfx from './drivers/gfx';\nimport Keyboard from './drivers/keyboard';\nimport { IChip, IChipContext } from './types/chip.types';\n\n/**\n * export some common stuff\n */\n\nexport const games = [\n  'Brix',\n  'Invaders',\n  'Tetris',\n  'Pong',\n  'UFO',\n  'IBM',\n  'Missile',\n  'Tank',\n  'Maze'\n];\n\nexport const keypad = [\n  ['1', '2', '3', '4'],\n  ['q', 'w', 'e', 'r'],\n  ['a', 's', 'd', 'f'],\n  ['z', 'x', 'c', 'v']\n];\n\nexport const instructions: IInstructions = {\n  brix: 'Left: Q | Right: E',\n  tetris: 'Left: W | Right: E | Rotate: Q',\n  pong: 'P1 Up: 1 | P1 Down: Q | P2 Up: 4 | P2 Down: R',\n  ufo: 'Up/Left: Q | Up: W | Up/Right: E',\n  ibm: 'None',\n  invaders: 'Start: W | Shoot: W| Left: Q | Right: R',\n  missile: 'Shoot: S',\n  tank: 'Shoot: W | Left: Q | Up: S | Right: E | Down: 2',\n  maze: 'None'\n};\n\nexport interface SpecialCases {\n  [key: string]: any;\n}\n\nexport interface IInstructions {\n  [key: string]: string;\n}\n\nexport default class Chip {\n  /**\n   * Configure our preferred target framerate\n   * We'll also configure our frame pointer and play state\n   * Timing function from https://gist.github.com/addyosmani/5434533#gistcomment-2018050\n   */\n\n  speed = 60;\n  frame = 0;\n\n  /**\n   * stub our cpu and gfx so we can access them publicly\n   */\n\n  public cpu;\n  public gfx;\n  public keyboard;\n\n  /**\n   * lets fine tune some specific games\n   * our maximum is 1000\n   */\n\n  specialCases: SpecialCases = {};\n\n  /**\n   * i couldnt figure out how to make typescript happy with canvas so i've checked it can't be null up the chain - bit risky tho\n   *\n   * @param rom - a CHIP-8 rom file as a Uint8Array\n   * @param canvas - an html canvas element for our renderer\n   */\n\n  constructor(game: string, rom: Uint8Array, canvas: any) {\n    this.dispatch.bind(this);\n\n    /**\n     * before we do anything check for special cases\n     */\n\n    if (this.specialCases[game.toLowerCase()]) {\n      this.speed = this.specialCases[game.toLowerCase()].speed || this.speed;\n    }\n\n    const gfx = new Gfx(canvas);\n    const cpu = new Cpu(rom, gfx);\n\n    this.cpu = cpu;\n    this.gfx = gfx;\n\n    this.keyboard = new Keyboard(cpu);\n\n    this.start(cpu, gfx);\n  }\n\n  /**\n   * Custom event dispatcher so a 3rd party can listen in on what's happening\n   * under the hood of chip\n   */\n\n  dispatch(context: IChip) {\n    if (CustomEvent instanceof Function) {\n      const data = {\n        cpu: context.cpu,\n        frame: context.frame,\n        speed: context.speed\n      };\n\n      const cpuEvent = new CustomEvent('chipDebug', { detail: data });\n\n      document.dispatchEvent(cpuEvent);\n    }\n  }\n\n  /**\n   * start will kick off our timing function\n   * this is going to check 60 times per second\n   * requestAnimationFrame is a browser API that helps us\n   * with render timing\n   */\n\n  start(cpu: Cpu, gfx: Gfx) {\n    let working = false;\n\n    const context: IChipContext = {\n      frame: this.frame,\n      speed: this.speed\n    };\n\n    /**\n     * let's start a clock\n     */\n\n    setInterval(() => {\n      if (working) {\n        return;\n      }\n\n      working = true;\n      cpu.next(this.dispatch, context);\n      working = false;\n    }, 1000 / this.speed);\n\n    const animateLoop = () => {\n      this.frame = requestAnimationFrame(animateLoop);\n\n      const screen = cpu.display;\n      gfx.paint(screen);\n    };\n\n    /**\n     * Once started the animateLoop function will call itself recursively\n     */\n\n    this.frame = requestAnimationFrame(animateLoop);\n  }\n\n  /**\n   * shut it all down fellas\n   * only call this if you're about to destroy the class\n   * this ensures event listeners and audio loops are destroyed\n   */\n  public stop() {\n    cancelAnimationFrame(this.frame);\n    this.cpu.halt();\n  }\n}\n","import './StackView.scss';\n\ninterface IStackView {\n  data: Uint8Array | Uint16Array;\n}\n\nexport default function StackView(props: IStackView) {\n  const { data } = props;\n\n  const array = Array.from(data);\n\n  return array && array.length > 0 ? (\n    <table className=\"stack-view w-100 text-center\">\n      <thead>\n        <tr>\n          {array.map((_item, i) => (\n            <td key={i}>{i}</td>\n          ))}\n        </tr>\n      </thead>\n      <tbody>\n        <tr>\n          {array.map((item, i) => (\n            <td key={i}>\n              <div className=\"ratio ratio-1x1 bg-primary text-bg-primary text-center rounded\">\n                <div>{item}</div>\n              </div>\n            </td>\n          ))}\n        </tr>\n      </tbody>\n    </table>\n  ) : (\n    <strong>'No data'</strong>\n  );\n}\n","import StackView from './views/StackView/StackView';\n\nimport './DebugArrayTable.scss';\n\ninterface IDebugArrayTable {\n  data: Uint8Array | Uint16Array;\n  format: 'table' | 'stack';\n  columns?: number;\n}\n\nexport default function DebugArrayTable(props: IDebugArrayTable) {\n  const { data, format } = props;\n\n  return (\n    <div className=\"debug-array-table\">\n      {format === 'stack' ? (\n        <StackView data={data} />\n      ) : (\n        <table className=\"table w-100\">\n          <tbody>\n            <tr>\n              <th scope=\"row\">1</th>\n              <td>Mark</td>\n              <td>Otto</td>\n              <td>@mdo</td>\n            </tr>\n          </tbody>\n        </table>\n      )}\n    </div>\n  );\n}\n","import { useState, useEffect, useRef, useCallback } from 'react';\nimport { Field, Form, Formik } from 'formik';\nimport request from 'axios';\nimport isClient from '@bagofholding/is-client';\nimport Collapsible from 'react-collapsible';\n\nimport arrayBuffer from '../../polyfills/arrayBuffer';\nimport Chip, { games, keypad, instructions } from '../../libs/chip/chip';\nimport { IChip } from '../../libs/chip/types/chip.types';\n\nimport './App.scss';\nimport DebugArrayTable from '../../components/DebugArrayTable/DebugArrayTable';\n\nfunction App() {\n  const canvas = useRef(null);\n\n  const [slot, setSlot] = useState(games[0].toLowerCase());\n  const [debugDetail, setDebugDetail] = useState({} as IChip);\n\n  const fetchData = useCallback(async () => {\n    /**\n     * check for any instances of chip before we load a rom\n     */\n    if (window.chip) {\n      window.chip.stop();\n    }\n    /**\n     * sadly superagent does not support blobs in userland\n     * we have retired it here in favour of axios\n     */\n    const response = await request({\n      url: `${process.env.PUBLIC_URL}/roms/${slot}`,\n      method: 'GET',\n      responseType: 'blob'\n    });\n\n    /**\n     * check if we need a fileArray polyfill\n     */\n\n    File.prototype.arrayBuffer = File.prototype.arrayBuffer || arrayBuffer;\n    Blob.prototype.arrayBuffer = Blob.prototype.arrayBuffer || arrayBuffer;\n\n    const blob = new Blob([response.data]);\n    const buffer = await blob.arrayBuffer();\n    const rom = new Uint8Array(buffer);\n    const chip = new Chip(slot, rom, canvas);\n\n    window.chip = chip;\n  }, [slot]);\n\n  useEffect(() => {\n    if (isClient() && canvas && canvas?.current) {\n      fetchData();\n    }\n  }, [slot, canvas, fetchData]);\n\n  const handleButtonPress = (key: string) => {\n    if (isClient()) {\n      window.chip.keyboard.press(key);\n\n      /**\n       * we then wait a little time to fake a real keypress\n       * the key needs to be released manually\n       */\n\n      setTimeout(() => {\n        window.chip.keyboard.release();\n      }, 200);\n    }\n  };\n\n  const handleToggleGrid = () => {\n    if (isClient()) {\n      window.chip.gfx.toggleGrid();\n    }\n  };\n\n  /**\n   * event listener for debug view\n   */\n\n  const handleDebugListener = useCallback(event => {\n    setDebugDetail(event.detail);\n    console.log(event.detail.cpu);\n  }, []);\n\n  useEffect(() => {\n    document.addEventListener('chipDebug', handleDebugListener);\n    return () => {\n      document.removeEventListener('chipDebug', handleDebugListener);\n    };\n  }, [handleDebugListener]);\n\n  return (\n    <div className=\"container app\">\n      <div className=\"row\">\n        <div className=\"col-12 text-center mb-3\">\n          <h1 className=\"mb-0\">CHIP.ts</h1>\n          <h2>\n            <small className=\"text-muted\">\n              A CHIP-8 emulator in TypeScript\n            </small>\n          </h2>\n          <canvas data-testid=\"canvas\" ref={canvas} />\n        </div>\n      </div>\n\n      <div className=\"row\">\n        <div className=\"col-12 text-center mb-2\">\n          <button\n            className=\"btn btn-secondary\"\n            onClick={() => {\n              handleButtonPress('Escape');\n            }}\n          >\n            Pause (Escape / Spacebar)\n          </button>\n        </div>\n        <div className=\"col-6 text-center mb-2 d-none\">\n          <button\n            className=\"btn btn-secondary\"\n            onClick={() => {\n              handleToggleGrid();\n            }}\n          >\n            Toggle Grid\n          </button>\n        </div>\n        <div className=\"col-12\">\n          {/** virtual keypad */}\n          {keypad.map((row, i) => (\n            <div key={i} className=\"row\">\n              {row.map((column: string) => (\n                <div key={column} className=\"col-3 text-center mb-2\">\n                  <button\n                    className=\"btn btn-secondary w-100\"\n                    onClick={() => {\n                      handleButtonPress(column);\n                    }}\n                  >\n                    {column.toUpperCase()}\n                  </button>\n                </div>\n              ))}\n            </div>\n          ))}\n        </div>\n      </div>\n\n      {instructions[slot] && (\n        <div className=\"row\">\n          <div className=\"col-12\">\n            <div className=\"alert alert-secondary\" role=\"alert\">\n              <h2>{slot} keys:</h2>\n              {instructions[slot.toLowerCase()]}\n            </div>\n          </div>\n        </div>\n      )}\n      <Formik\n        initialValues={{ slot }}\n        onSubmit={values => {\n          if (values.slot !== slot) {\n            setSlot(values.slot);\n          }\n        }}\n      >\n        <Form className=\"row justify-content-lg-center\">\n          <div className=\"col-12 text-center\">\n            <h3>Choose a cartidge</h3>\n            <Field as=\"select\" className=\"form-control\" name=\"slot\">\n              {games.map(game => (\n                <option key={game} value={game.toLowerCase()}>\n                  {game}\n                </option>\n              ))}\n            </Field>\n            <hr />\n            <button className=\"btn btn-primary\" type=\"submit\">\n              Load\n            </button>\n            <hr />\n          </div>\n        </Form>\n      </Formik>\n      {Object.keys(debugDetail).length > 0 && (\n        <div className=\"row\">\n          <div className=\"col-12\">\n            <Collapsible\n              trigger=\"Debug\"\n              triggerTagName={'button'}\n              triggerClassName=\"btn btn-primary d-block mx-auto\"\n              triggerOpenedClassName=\"btn btn-primary d-block mx-auto\"\n            >\n              <div className=\"d-block w-100\">\n                <table className=\"table table-dark debug-table\">\n                  <thead>\n                    <tr>\n                      <th scope=\"col\">Key</th>\n                      <th scope=\"col\">Value</th>\n                    </tr>\n                  </thead>\n                  <tbody>\n                    <tr>\n                      <th scope=\"row\">Speed</th>\n                      <td>{debugDetail?.speed}</td>\n                    </tr>\n                    <tr>\n                      <th scope=\"row\">Frame</th>\n                      <td>{debugDetail?.frame}</td>\n                    </tr>\n                    {/** cpu */}\n                    <tr>\n                      <th scope=\"row\">Cpu Counter</th>\n                      <td>{debugDetail?.cpu?.counter}</td>\n                    </tr>\n                    <tr>\n                      <th scope=\"row\">Cpu Delay Timer</th>\n                      <td>{debugDetail?.cpu?.delayTimer}</td>\n                    </tr>\n                    <tr>\n                      <th scope=\"row\">Cpu Key Pressed</th>\n                      <td>{debugDetail?.cpu?.key}</td>\n                    </tr>\n                    {/* <tr>\n                      <th scope=\"row\">Cpu Memory</th>\n                      <td>{debugDetail?.cpu?.memory}</td>\n                    </tr> */}\n                    <tr>\n                      <th scope=\"row\">Cpu Pointer</th>\n                      <td>{debugDetail?.cpu?.pointer}</td>\n                    </tr>\n                    <tr>\n                      <th scope=\"row\">Cpu Registers</th>\n                      <td>\n                        <DebugArrayTable\n                          data={debugDetail?.cpu?.registers}\n                          format={'stack'}\n                        />\n                      </td>\n                    </tr>\n                    <tr>\n                      <th scope=\"row\">Cpu Running</th>\n                      <td>{String(debugDetail?.cpu?.running)}</td>\n                    </tr>\n                    {/* <tr>\n                      <th scope=\"row\">Cpu Screen</th>\n                      <td>{debugDetail?.cpu?.screen}</td>\n                    </tr> */}\n                    <tr>\n                      <th scope=\"row\">Cpu Sound Timer</th>\n                      <td>{debugDetail?.cpu?.soundTimer}</td>\n                    </tr>\n                    <tr>\n                      <th scope=\"row\">Cpu Stack</th>\n                      <td>\n                        <DebugArrayTable\n                          data={debugDetail?.cpu?.stack}\n                          format={'stack'}\n                        />\n                      </td>\n                    </tr>\n                    <tr>\n                      <th scope=\"row\">Cpu Stack Pointer</th>\n                      <td>{debugDetail?.cpu?.stackPointer}</td>\n                    </tr>\n                  </tbody>\n                </table>\n              </div>\n            </Collapsible>\n          </div>\n          <div className=\"col-12 text-center\">\n            <hr />\n            <a\n              className=\"btn btn-light\"\n              href=\"https://github.com/PenguinOfWar/chip.ts\"\n            >\n              View code on GitHub\n            </a>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\ndeclare global {\n  interface Window {\n    chip: Chip;\n  }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './containers/App/App';\n\nimport reportWebVitals from './reportWebVitals';\n\nimport './sass/index.scss';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}